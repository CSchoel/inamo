<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples (full runnable models) · InaMo</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">InaMo</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">InaMo</a></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../cells/">Full cell models</a></li><li><a class="tocitem" href="../membrane/">Membrane model</a></li><li><a class="tocitem" href="../channels/">Ion channels</a></li><li><a class="tocitem" href="../concentrations/">Ion concentrations</a></li><li><a class="tocitem" href="../pumps/">Ion pumps</a></li><li><a class="tocitem" href="../experimental-methods/">Experimental methods</a></li></ul></li><li><span class="tocitem">Modelica features</span><ul><li><a class="tocitem" href="../../extends/">Ineritance in InaMo</a></li><li><a class="tocitem" href="../../outer/">Outer parameters</a></li><li><a class="tocitem" href="../../replaceable/">Replaceable functions</a></li><li><a class="tocitem" href="../../acausal/">Acausal connectors</a></li></ul></li><li><a class="tocitem" href="../../unit-tests/">Unit tests</a></li><li><a class="tocitem" href="../../ci/">Continuous integration</a></li><li><a class="tocitem" href="../../reconstruction/">Plot reconstruction</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples (full runnable models)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples (full runnable models)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CSchoel/inamo/blob/master/docs/src/models/examples.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples-(full-runnable-models)"><a class="docs-heading-anchor" href="#Examples-(full-runnable-models)">Examples (full runnable models)</a><a id="Examples-(full-runnable-models)-1"></a><a class="docs-heading-anchor-permalink" href="#Examples-(full-runnable-models)" title="Permalink"></a></h1><h2 id="Interfaces"><a class="docs-heading-anchor" href="#Interfaces">Interfaces</a><a id="Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Interfaces" title="Permalink"></a></h2>
      <p>This model can be used as a basis for experiments that capture the
      current-voltage relationship of a single channel or ion pump.
      It will use a voltage clamp test pulse protocol with pulse amplitudes
      starting from v_start and continuously increasing by v_inc with each
      pulse.</p>
      <p>To calculate the correct StopTime needed for the simulation of pulses
      starting with v_start and ending with v_end, you can use the following
      formula:</p>
      <code>
        StopTime = ((v_end - v_start) / v_inc + 3) * (d_hold + d_pulse) - d_pulse
      </code>
      <p>The offset of 3 * (d_hold + d_pulse) is required because the first
      value for vc.is_peak, vc.is_end and vc.is_tail is obtained after
      2 * d_hold and the last value is obtained d_hold seconds after the
      pulse with amplitude v_end.</p>
      <p>d_pulse and d_hold should either be chosen according to reference or
      roughly such that d_pulse > 5 * tau_act and d_hold > 5 * tau_inact where
      tau_act is the time constant of the activation and tau_inact is the time
      constant of inactivation of the simulated channel.
      This ensures that there is enough time to observe the characteristic
      time course of activation and inactivation and that the channel is close
      to its steady state at holding potential before the next pulse.</p>
    <pre><code class="language-modelica">partial model IVBase &quot;base for all experiments for current-voltage relationship&quot;
  extends InaMo.Icons.PartialExample;
  InaMo.ExperimentalMethods.VoltageClamp.VCTestPulsesPeak vc &quot;voltage pulse protocol&quot; annotation(
    Placement(transformation(extent = {{-17, -17}, {17, 17}})));
  parameter SI.Voltage v_start = -0.08 &quot;start value for pulse amplitude&quot;;
  parameter SI.Voltage v_inc = 0.005 &quot;increment for pulse amplitude&quot;;
initial equation
  vc.v_pulse = v_start;
equation
  when vc.pulse_end then
    vc.v_pulse = pre(vc.v_pulse) + v_inc;
  end when;
  annotation(
    Documentation(info = &quot;
    &lt;html&gt;
      &lt;p&gt;This model can be used as a basis for experiments that capture the
      current-voltage relationship of a single channel or ion pump.
      It will use a voltage clamp test pulse protocol with pulse amplitudes
      starting from v_start and continuously increasing by v_inc with each
      pulse.&lt;/p&gt;
      &lt;p&gt;To calculate the correct StopTime needed for the simulation of pulses
      starting with v_start and ending with v_end, you can use the following
      formula:&lt;/p&gt;
      &lt;code&gt;
        StopTime = ((v_end - v_start) / v_inc + 3) * (d_hold + d_pulse) - d_pulse
      &lt;/code&gt;
      &lt;p&gt;The offset of 3 * (d_hold + d_pulse) is required because the first
      value for vc.is_peak, vc.is_end and vc.is_tail is obtained after
      2 * d_hold and the last value is obtained d_hold seconds after the
      pulse with amplitude v_end.&lt;/p&gt;
      &lt;p&gt;d_pulse and d_hold should either be chosen according to reference or
      roughly such that d_pulse &gt; 5 * tau_act and d_hold &gt; 5 * tau_inact where
      tau_act is the time constant of the activation and tau_inact is the time
      constant of inactivation of the simulated channel.
      This ensures that there is enough time to observe the characteristic
      time course of activation and inactivation and that the channel is close
      to its steady state at holding potential before the next pulse.&lt;/p&gt;
    &lt;/html&gt;
  &quot;));
end IVBase;</code></pre><h2 id="Full-cell-examples"><a class="docs-heading-anchor" href="#Full-cell-examples">Full cell examples</a><a id="Full-cell-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Full-cell-examples" title="Permalink"></a></h2><h2 id="Tests-for-Ca2-handling"><a class="docs-heading-anchor" href="#Tests-for-Ca2-handling">Tests for Ca2+ handling</a><a id="Tests-for-Ca2-handling-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-for-Ca2-handling" title="Permalink"></a></h2><h2 id="Tests-for-I_f"><a class="docs-heading-anchor" href="#Tests-for-I_f">Tests for <span>$I_f$</span></a><a id="Tests-for-I_f-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-for-I_f" title="Permalink"></a></h2>
      <p>To reproduce Figure S4C from Inada 2009, plot vc.is_end against
      vc.vs_end.
      It is necessary to use vc.vs_end instead of vc.v_pulse, because cd
      captures the current density from the <i>previous</i> pulse.</p>
      <p>For Figure S4D plot vc.i for 6 seconds following the start of
      the pulses with amplitude -120 to -60 mV.</p>
      <p>Simulation protocol and parameters are chosen with the following
      rationale:</p>
      <ul>
        <li>StopTime: allow a plot from -120 mV to -50 mv</li>
        <li>Tolerance: default value</li>
        <li>Interval: enough to roughly follow time course of current</li>
        <li>d_pulse: according to the description of Figure S4 in Inada 2009</li>
        <li>d_hold: approximately 5 * max(act.tau)</li>
        <li>l2.C: according to Table S15 in Inada 2009 (N cell model)</li>
      </ul>
      <p>We assume the parameter values for the N cell model since I_f is
      only present in N cells.</p>
      <p>NOTE: The plot has a disagreement with Figure S4C in Inada 2009
      with current density being slightly lower (more negative) than in the
      reference, which is odd, since the same data is in perfect agreement
      with Figure S4D.</p>
    <pre><code class="language-modelica">model HyperpolarizationActivatedIV &quot;IV relationship of I_f, recreates Figures S4C and S4D from Inada 2009&quot;
  extends InaMo.Examples.Interfaces.IVBase(vc(v_hold = -0.05, d_hold = 20, d_pulse = 4), v_start = -0.12, v_inc = 0.005);
  extends Modelica.Icons.Example;
  extends InaMo.Concentrations.Interfaces.NoACh;
  InaMo.Currents.Atrioventricular.HyperpolarizationActivatedChannel f &quot;I_f&quot; annotation(
    Placement(transformation(extent = {{-51, -17}, {-17, 17}})));
  InaMo.Membrane.LipidBilayer l2(use_init = false, c = 29e-12) &quot;cell membrane&quot; annotation(
    Placement(transformation(extent = {{17, -17}, {51, 17}})));
equation
  connect(l2.p, vc.p) annotation(
    Line(points = {{34, 18}, {34, 18}, {34, 40}, {0, 40}, {0, 18}, {0, 18}}, color = {0, 0, 255}));
  connect(vc.p, f.p) annotation(
    Line(points = {{0, 18}, {0, 18}, {0, 40}, {-34, 40}, {-34, 18}, {-34, 18}}, color = {0, 0, 255}));
  connect(l2.n, vc.n) annotation(
    Line(points = {{34, -16}, {34, -16}, {34, -40}, {0, -40}, {0, -16}, {0, -16}}, color = {0, 0, 255}));
  connect(vc.n, f.n) annotation(
    Line(points = {{0, -16}, {0, -16}, {0, -40}, {-34, -40}, {-34, -16}, {-34, -16}}, color = {0, 0, 255}));
  annotation(
    experiment(StartTime = 0, StopTime = 404, Tolerance = 1e-6, Interval = 1e-1),
    __OpenModelica_simulationFlags(lv = &quot;LOG_STATS&quot;, s = &quot;dassl&quot;),
    __MoST_experiment(variableFilter = &quot;vc\\.(is_end|vs_end|i|v|v_pulse)&quot;),
    Documentation(info = &quot;
    &lt;html&gt;
      &lt;p&gt;To reproduce Figure S4C from Inada 2009, plot vc.is_end against
      vc.vs_end.
      It is necessary to use vc.vs_end instead of vc.v_pulse, because cd
      captures the current density from the &lt;i&gt;previous&lt;/i&gt; pulse.&lt;/p&gt;
      &lt;p&gt;For Figure S4D plot vc.i for 6 seconds following the start of
      the pulses with amplitude -120 to -60 mV.&lt;/p&gt;
      &lt;p&gt;Simulation protocol and parameters are chosen with the following
      rationale:&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;StopTime: allow a plot from -120 mV to -50 mv&lt;/li&gt;
        &lt;li&gt;Tolerance: default value&lt;/li&gt;
        &lt;li&gt;Interval: enough to roughly follow time course of current&lt;/li&gt;
        &lt;li&gt;d_pulse: according to the description of Figure S4 in Inada 2009&lt;/li&gt;
        &lt;li&gt;d_hold: approximately 5 * max(act.tau)&lt;/li&gt;
        &lt;li&gt;l2.C: according to Table S15 in Inada 2009 (N cell model)&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;We assume the parameter values for the N cell model since I_f is
      only present in N cells.&lt;/p&gt;
      &lt;p&gt;NOTE: The plot has a disagreement with Figure S4C in Inada 2009
      with current density being slightly lower (more negative) than in the
      reference, which is odd, since the same data is in perfect agreement
      with Figure S4D.&lt;/p&gt;
    &lt;/html&gt;
  &quot;));
end HyperpolarizationActivatedIV;</code></pre><ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mrow><mi> l2.i 
</mi></mrow><mo>+</mo><mrow><mo>(</mo><mrow><mi> f.i_ion 
</mi></mrow><mo>&#8722;</mo><mrow><mi> vc.i 
</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8801;</mo><mn> 0.0 
</mn></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi> l2.v 
</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mi> l2.i 
</mi></mrow><mo>/</mo><mrow><mi> l2.c 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> vc.within_pulse 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mi> time 
</mi></mrow><mo>&#8722;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.tp_last 
</mi></mrow><mo>)</mo></mrow></mrow></mrow><mo>&lt;</mo><mrow><mi> vc.d_pulse 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> vc.after_pulse 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mi> time 
</mi></mrow><mo>&#8722;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.tp_last 
</mi></mrow><mo>)</mo></mrow></mrow></mrow><mo>&gt;</mo><mrow><mi> vc.d_pulse 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition1 
</mi></mrow><mo>&#8801;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition2 
</mi></mrow><mo>&#8801;</mo><mrow><mi> vc.pulse_start 
</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition3 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>&#8800;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow><mo>&#8743;</mo><mrow><mi> vc.after_pulse 
</mi></mrow><mo>)</mo></mrow><mo>&#8744;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition4 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>&#8800;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow><mo>&#8743;</mo><mrow><mi> vc.within_pulse 
</mi></mrow><mo>)</mo></mrow><mo>&#8744;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow></mrow>
</math>
<li>Within group f (prefix _ indicates shortened variable name)
<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi>_act.n</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mi>_act.steady</mi></mrow><mo>&#8722;</mo><mrow><mi>_act.n</mi></mrow><mo>)</mo></mrow><mo>/</mo><mrow><mi>_act.tau</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_i_open</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_g_max</mi></mrow><mo>&sdot;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>&#8722;</mo><mrow><mi>_v_eq</mi></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_i_ion</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_act.n</mi></mrow><mo>&sdot;</mo><mrow><mi>_i_open</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_g</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_act.n</mi></mrow><mo>&sdot;</mo><mrow><mi>_g_max</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_act.steady</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>fsteady</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mrow><mi> l2.v 
</mi></mrow><mo>&#8722;</mo><mrow><mi>_act.shift</mi></mrow></mrow><mo>,</mo><mn> 0.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> -0.08319 
</mn><mo>,</mo><mn> -73.74631268436578 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_act.tau</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>ftau</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.25 
</mn><mo>,</mo><mn> 2.25 
</mn><mo>,</mo><mn> -0.07000000000000001 
</mn><mo>,</mo><mn> 0.0158113883008419 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
</ol>

<li>Within group vc (prefix _ indicates shortened variable name)
<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mrow><mi>_g.p.i</mi></mrow><mo>+</mo><mrow><mo>(</mo><mrow><mi>_i</mi></mrow><mo>&#8722;</mo><mrow><mi>_n.i</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8801;</mo><mn> 0.0 
</mn></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_i</mi></mrow><mo>&#8801;</mo><mrow><mi>_n.i</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> l2.v 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mo>&#8475;</mo><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi>_pulse_signal</mi></mrow><mo>)</mo></mrow></mrow><mo>&sdot;</mo><mrow><mo>(</mo><mrow><mi>_v_pulse</mi></mrow><mo>&#8722;</mo><mrow><mi>_v_hold</mi></mrow><mo>)</mo></mrow></mrow><mo>+</mo><mrow><mi>_v_hold</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_pulse_start</mi></mrow><mo>&#8801;</mo><mrow><sample/><mo>&#8289;</mo><mrow><mo>(</mo><mn> 1 
</mn><mo>,</mo><mrow><mi>_d_hold</mi></mrow><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_pulse_end</mi></mrow><mo>&#8801;</mo><mrow><sample/><mo>&#8289;</mo><mrow><mo>(</mo><mn> 2 
</mn><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_peak_indicator</mi></mrow><mo>&#8801;</mo><mrow><mrow><msup><mrow><mrow><mi>_i</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#215;</mo><mn> 1000000000000.0 
</mn></mrow><mo>&lt;</mo><mn> 0.0 
</mn></mrow></mrow>
</math>
</ol>

</ol>
<p>Functions:</p><pre><code class="language-modelica">function fsteady
  input Real x &quot;input value&quot;;
  input Real y_min = 0.0 &quot;lower asymptote (fitting parameter)&quot;;
  input Real y_max = 1.0 &quot;upper asmyptote when d_off=1 and nu=1 (fititng parameter)&quot;;
  input Real x0 = -0.08319 &quot;x-value of sigmoid midpoint when d_off=1 and nu=1 (fitting parameter)&quot;;
  input Real sx = -73.74631268436578 &quot;scaling factor for x axis (i.e. steepness, fitting parameter)&quot;;
  input Real se = 1.0 &quot;scaling factor for exponential part (fitting parameter)&quot;;
  input Real d_off = 1.0 &quot;offset in denominator (affects upper asymptote, fitting parameter)&quot;;
  input Real nu = 1.0 &quot;reciprocal of exponent of denominator (affects upper asymptote, fitting parameter)&quot;;
  output Real y &quot;result&quot;;
  protected Real x_adj &quot;adjusted x with offset and scaling factor&quot;;
algorithm
  x_adj := sx * (x - x0);
  y := y_min + (y_max - y_min) / (se * exp(-x_adj) + d_off) ^ (1.0 / nu);
end fsteady;</code></pre><pre><code class="language-modelica">function hillLangmuir &quot;Hill-Langmuir equation measuring the occupancy of a molecule by a ligand&quot;
  input Real c(quantity = &quot;Concentration&quot;, unit = &quot;mol/m3&quot;) &quot;ligand concentration&quot;;
  input Real ka(quantity = &quot;Concentration&quot;, unit = &quot;mol/m3&quot;) &quot;concentration producing half occupation&quot;;
  input Real n(unit = &quot;1&quot;) &quot;Hill coefficient&quot;;
  output Real rate(unit = &quot;1&quot;) &quot;occupancy of molecule by ligand&quot;;
algorithm
  rate := c ^ n / (c ^ n + ka ^ n);
end hillLangmuir;</code></pre><pre><code class="language-modelica">function absmax &quot;returns input whose absolute value is larger, preserving the sign&quot;
  input Real a &quot;first input&quot;;
  input Real b &quot;second input&quot;;
  output Real m &quot;a if abs(a) &gt; abs(b), otherwise b&quot;;
algorithm
  m := if abs(a) &gt; abs(b) then a else b;
end absmax;</code></pre><pre><code class="language-modelica">function ftau
  input Real x &quot;input value&quot;;
  input Real y_min = 0.25 &quot;minimum value achieved at edges (fitting parameter)&quot;;
  input Real y_max = 2.25 &quot;maximum value achieved at peak (fititng parameter)&quot;;
  input Real x0 = -0.07000000000000001 &quot;x-value of bell curve midpoint (fitting parameter)&quot;;
  input Real sigma = 0.0158113883008419 &quot;standard deviation determining the width of the bell curve (fitting parameter)&quot;;
  output Real y &quot;result&quot;;
  protected Real x_adj &quot;adjusted x with offset and standard deviation&quot;;
algorithm
  x_adj := (x - x0) / sigma;
  y := y_min + (y_max - y_min) * exp(-0.5 * x_adj ^ 2.0);
end ftau;</code></pre><table><tr><th style="text-align: right">name</th><th style="text-align: right">unit</th><th style="text-align: right">value</th><th style="text-align: right">label</th></tr><tr><td style="text-align: right">l2.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing from pin p to pin n</td></tr><tr><td style="text-align: right">l2.v</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right"></td><td style="text-align: right">Voltage drop of the two pins (= p.v - n.v)</td></tr><tr><td style="text-align: right">f.act.tau</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right"></td><td style="text-align: right">time constant for obtaining steady state (i.e. time until difference between n and steady has reduced by a factor of 1/e)</td></tr><tr><td style="text-align: right">f.act.steady</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">value that n would reach if v_gate was held constant</td></tr><tr><td style="text-align: right">f.act.n</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right">0.002161140405175932</td><td style="text-align: right">ratio of molecules in open conformation</td></tr><tr><td style="text-align: right">f.g</td><td style="text-align: right">&quot;S&quot;</td><td style="text-align: right"></td><td style="text-align: right">ion conductance</td></tr><tr><td style="text-align: right">f.i_open</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">i if open_ratio = 1</td></tr><tr><td style="text-align: right">f.i_ion</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">current used for ion flux</td></tr><tr><td style="text-align: right">vc.after_pulse</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">true after pulse has passed</td></tr><tr><td style="text-align: right">vc.within_pulse</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">true during pulse</td></tr><tr><td style="text-align: right">vc.vp_last</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">voltage of last pulse</td></tr><tr><td style="text-align: right">vc.tp_last</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">time stamp of start of last pulse</td></tr><tr><td style="text-align: right">vc.peak_indicator</td><td style="text-align: right"></td><td style="text-align: right">false</td><td style="text-align: right">forces event at peak (factor of 1e12 is required to detect zero crossing)</td></tr><tr><td style="text-align: right">vc.tail_i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">peak current after pulse</td></tr><tr><td style="text-align: right">vc.peak_i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">peak current during pulse</td></tr><tr><td style="text-align: right">vc.vs_tail</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_tail</td></tr><tr><td style="text-align: right">vc.vs_end</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_end</td></tr><tr><td style="text-align: right">vc.vs_peak</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_peak</td></tr><tr><td style="text-align: right">vc.is_end</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of current at end of last pulse</td></tr><tr><td style="text-align: right">vc.is_tail</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of peak tail current after last pulse</td></tr><tr><td style="text-align: right">vc.is_peak</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of peak current during last pulse</td></tr><tr><td style="text-align: right">vc.v_pulse</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right"></td><td style="text-align: right">voltage during pulse (must be defined externally)</td></tr><tr><td style="text-align: right">vc.pulse_signal</td><td style="text-align: right"></td><td style="text-align: right">0</td><td style="text-align: right">0 during holding period, 1 during pulse</td></tr><tr><td style="text-align: right">vc.pulse_end</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">signals end of pulse</td></tr><tr><td style="text-align: right">vc.pulse_start</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">signals start of pulse</td></tr><tr><td style="text-align: right">vc.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">measured membrane current</td></tr><tr><td style="text-align: right">vc.g.p.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing into the pin</td></tr><tr><td style="text-align: right">vc.n.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing into the pin</td></tr><tr><td style="text-align: right">$whenCondition1</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.pulse_end</td></tr><tr><td style="text-align: right">$whenCondition2</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.pulse_start</td></tr><tr><td style="text-align: right">$whenCondition3</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.peak_indicator &lt;&gt; pre(vc.peak_indicator) and vc.after_pulse or vc.pulse_end</td></tr><tr><td style="text-align: right">$whenCondition4</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.peak_indicator &lt;&gt; pre(vc.peak_indicator) and vc.within_pulse or vc.pulse_end</td></tr><tr><td style="text-align: right">vc.g.p.v</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">Potential at the pin</td></tr><tr><td style="text-align: right">vc.d_hold</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">20.0</td><td style="text-align: right">holding period</td></tr><tr><td style="text-align: right">vc.d_pulse</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">4.0</td><td style="text-align: right">pulse period</td></tr><tr><td style="text-align: right">vc.v_hold</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.05</td><td style="text-align: right">voltage during holding period</td></tr><tr><td style="text-align: right">v_start</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.12</td><td style="text-align: right">start value for pulse amplitude</td></tr><tr><td style="text-align: right">v_inc</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.005</td><td style="text-align: right">increment for pulse amplitude</td></tr><tr><td style="text-align: right">use_ach</td><td style="text-align: right"></td><td style="text-align: right">false</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">ach</td><td style="text-align: right">&quot;mol/m3&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">f.v_eq</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.03</td><td style="text-align: right">equilibrium potential</td></tr><tr><td style="text-align: right">f.g_max</td><td style="text-align: right">&quot;S&quot;</td><td style="text-align: right">1e-09</td><td style="text-align: right">maximum conductance</td></tr><tr><td style="text-align: right">f.current_name</td><td style="text-align: right"></td><td style="text-align: right">&quot;I_f&quot;</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">f.act_shift</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">if use_ach then (-7.2) * InaMo.Functions.Biochemical.hillLangmuir(ach, 1.26e-05, 0.6899999999999999) else 0.0</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">f.act.shift</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">f.act_shift</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">l2.c</td><td style="text-align: right">&quot;F&quot;</td><td style="text-align: right">2.9e-11</td><td style="text-align: right">membrane capacitance</td></tr><tr><td style="text-align: right">l2.v_init</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.09</td><td style="text-align: right">initial potential (from short initial stimulation)</td></tr><tr><td style="text-align: right">l2.use_init</td><td style="text-align: right"></td><td style="text-align: right">false</td><td style="text-align: right">determines whether initial value for v is used</td></tr></table>
      <p>To reproduce Figure S4A from Inada 2009, plot act_steady against v.
      For Figure S4B, plot act_tau against v.</p>
      <p>Simulation protocol and parameters are chosen with the following
      rationale:</p>
      <ul>
        <li>StopTime: allow a plot from -120 to -40 mV</li>
        <li>Tolerance: left at default value, since derivatives are not
        relevant</li>
        <li>Interval: enough for a smooth plot</li>
      </ul>
    <pre><code class="language-modelica">model HyperpolarizationActivatedSteady &quot;steady state of I_f, recreates Figures S4A and S4B from Inada 2009&quot;
  extends Modelica.Icons.Example;
  extends InaMo.Concentrations.Interfaces.NoACh;
  InaMo.Membrane.LipidBilayer l2(use_init = false) &quot;cell membrane&quot; annotation(
    Placement(transformation(extent = {{17, -17}, {51, 17}})));
  InaMo.ExperimentalMethods.VoltageClamp.VoltageClamp vc &quot;voltage clamp&quot; annotation(
    Placement(transformation(extent = {{-17, -17}, {17, 17}})));
  InaMo.Currents.Atrioventricular.HyperpolarizationActivatedChannel f &quot;I_f&quot; annotation(
    Placement(transformation(extent = {{-51, -17}, {-17, 17}})));
  Real act_steady = f.act.steady &quot;steady state of activation gate&quot;;
  Real act_tau = f.act.tau &quot;time constant of activation gate&quot;;
  SI.Voltage v(start = -0.12, fixed = true);
equation
  vc.v_stim = v;
  der(v) = 0.001;
  connect(l2.p, vc.p) annotation(
    Line(points = {{34, 18}, {34, 18}, {34, 40}, {0, 40}, {0, 18}, {0, 18}}, color = {0, 0, 255}));
  connect(vc.p, f.p) annotation(
    Line(points = {{0, 18}, {0, 18}, {0, 40}, {-34, 40}, {-34, 18}, {-34, 18}}, color = {0, 0, 255}));
  connect(l2.n, vc.n) annotation(
    Line(points = {{34, -16}, {34, -16}, {34, -40}, {0, -40}, {0, -16}, {0, -16}}, color = {0, 0, 255}));
  connect(vc.n, f.n) annotation(
    Line(points = {{0, -16}, {0, -16}, {0, -40}, {-34, -40}, {-34, -16}, {-34, -16}}, color = {0, 0, 255}));
  annotation(
    experiment(StartTime = 0, StopTime = 80, Tolerance = 1e-6, Interval = 1),
    __OpenModelica_simulationFlags(lv = &quot;LOG_STATS&quot;, s = &quot;dassl&quot;),
    __MoST_experiment(variableFilter = &quot;act_steady|act_tau|v|vc.v&quot;),
    Documentation(info = &quot;
    &lt;html&gt;
      &lt;p&gt;To reproduce Figure S4A from Inada 2009, plot act_steady against v.
      For Figure S4B, plot act_tau against v.&lt;/p&gt;
      &lt;p&gt;Simulation protocol and parameters are chosen with the following
      rationale:&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;StopTime: allow a plot from -120 to -40 mV&lt;/li&gt;
        &lt;li&gt;Tolerance: left at default value, since derivatives are not
        relevant&lt;/li&gt;
        &lt;li&gt;Interval: enough for a smooth plot&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/html&gt;
  &quot;));
end HyperpolarizationActivatedSteady;</code></pre><h2 id="Tests-for-I_{K,1}"><a class="docs-heading-anchor" href="#Tests-for-I_{K,1}">Tests for <span>$I_{K,1}$</span></a><a id="Tests-for-I_{K,1}-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-for-I_{K,1}" title="Permalink"></a></h2><h2 id="Tests-for-I_{Ca,L}"><a class="docs-heading-anchor" href="#Tests-for-I_{Ca,L}">Tests for <span>$I_{Ca,L}$</span></a><a id="Tests-for-I_{Ca,L}-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-for-I_{Ca,L}" title="Permalink"></a></h2>
    <p>To reproduce Figure S1E from Inada 2009, plot vc.is_peak against
    vc.vs_peak.
    It is necessary to use vc.vs_peak instead of vc.v_pulse, because vc.is_peak
    captures the peak current from the <i>previous</i> pulse.</p>
    <p>Simulation protocol and parameters are chosen with the following
    rationale:</p>
    <ul>
      <li>StopTime: allow a plot from -60 mV to 80 mv</li>
      <li>Tolerance: default value (previously a value < 1e-9 was required
        for dassl will to pick up the event for i_max.)</li>
      <li>Interval: enough to roughly follow time course of current</li>
      <li>d_pulse: according to the description of Figure S1 in Inada 2009</li>
      <li>d_hold: approximately 5 * max(cal.inact.tau_fast)</li>
      <li>v_hold: should be -40 mV according to the description of figure S1,
      but we chose -70 mV as it gives better results for pulses <= -40 mV</li>
      <li>l2.C: according to Table S15 in Inada 2009</li>
    </ul>
    <p>NOTE: We assume parameter values for the NH cell model since the plot for
    S1H shows that Inada et al. clearly used this model although they stated
    that the AN cell model was used for Figure S1H.
    For Figure S1E, however, the parameter value actually makes no difference
    because the plot shows only normalized current.</p>
    <pre><code class="language-modelica">model LTypeCalciumIV &quot;IV relationship of I_Ca,L, recreates Figure S1E of Inada 2009&quot;
  extends InaMo.Examples.Interfaces.IVBase(vc(v_hold = -0.07, d_hold = 5, d_pulse = 0.3), v_start = -0.06, v_inc = 0.005);
  extends Modelica.Icons.Example;
  extends InaMo.Concentrations.Interfaces.CaConst;
  extends InaMo.Concentrations.Interfaces.NoACh;
  inner parameter SI.Concentration ca_ex = 0 &quot;extracellular Ca2+ concentration (value not used in this simulation)&quot;;
  replaceable InaMo.Currents.Atrioventricular.LTypeCalciumChannel cal(g_max = 21e-9) &quot;calcium channels with parameters from NH model&quot; annotation(
    Placement(transformation(extent = {{-51, -17}, {-17, 17}})));
  InaMo.Concentrations.Basic.ConstantConcentration ca(vol = v_sub) &quot;calcium concentration that is affected by channel&quot; annotation(
    Placement(transformation(extent = {{-51, -80}, {-17, -46}})));
  InaMo.Membrane.LipidBilayer l2(use_init = false, c = 40e-12) &quot;cell membrane&quot; annotation(
    Placement(transformation(extent = {{17, -17}, {51, 17}})));
equation
  connect(ca.substance, cal.ca) annotation(
    Line(points = {{-34, -80}, {-14, -80}, {-14, -30}, {-28, -30}, {-28, -16}, {-28, -16}}));
  connect(l2.p, vc.p) annotation(
    Line(points = {{34, 18}, {34, 18}, {34, 40}, {0, 40}, {0, 18}, {0, 18}}, color = {0, 0, 255}));
  connect(vc.p, cal.p) annotation(
    Line(points = {{0, 18}, {0, 18}, {0, 40}, {-34, 40}, {-34, 18}, {-34, 18}}, color = {0, 0, 255}));
  connect(l2.n, vc.n) annotation(
    Line(points = {{34, -16}, {34, -16}, {34, -40}, {0, -40}, {0, -16}, {0, -16}}, color = {0, 0, 255}));
  connect(vc.n, cal.n) annotation(
    Line(points = {{0, -16}, {0, -16}, {0, -40}, {-34, -40}, {-34, -16}, {-34, -16}}, color = {0, 0, 255}));
  annotation(
    experiment(StartTime = 0, StopTime = 164, Tolerance = 1e-6, Interval = 1e-2),
    __OpenModelica_simulationFlags(lv = &quot;LOG_STATS&quot;, s = &quot;dassl&quot;),
    __MoST_experiment(variableFilter = &quot;vc\\.(is_peak|vs_peak|v|v_pulse)&quot;),
    Documentation(info = &quot;
    &lt;html&gt;
    &lt;p&gt;To reproduce Figure S1E from Inada 2009, plot vc.is_peak against
    vc.vs_peak.
    It is necessary to use vc.vs_peak instead of vc.v_pulse, because vc.is_peak
    captures the peak current from the &lt;i&gt;previous&lt;/i&gt; pulse.&lt;/p&gt;
    &lt;p&gt;Simulation protocol and parameters are chosen with the following
    rationale:&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;StopTime: allow a plot from -60 mV to 80 mv&lt;/li&gt;
      &lt;li&gt;Tolerance: default value (previously a value &lt; 1e-9 was required
        for dassl will to pick up the event for i_max.)&lt;/li&gt;
      &lt;li&gt;Interval: enough to roughly follow time course of current&lt;/li&gt;
      &lt;li&gt;d_pulse: according to the description of Figure S1 in Inada 2009&lt;/li&gt;
      &lt;li&gt;d_hold: approximately 5 * max(cal.inact.tau_fast)&lt;/li&gt;
      &lt;li&gt;v_hold: should be -40 mV according to the description of figure S1,
      but we chose -70 mV as it gives better results for pulses &lt;= -40 mV&lt;/li&gt;
      &lt;li&gt;l2.C: according to Table S15 in Inada 2009&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;NOTE: We assume parameter values for the NH cell model since the plot for
    S1H shows that Inada et al. clearly used this model although they stated
    that the AN cell model was used for Figure S1H.
    For Figure S1E, however, the parameter value actually makes no difference
    because the plot shows only normalized current.&lt;/p&gt;
    &lt;/html&gt;
  &quot;));
end LTypeCalciumIV;</code></pre><ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mrow><mi> l2.i 
</mi></mrow><mo>+</mo><mrow><mo>(</mo><mrow><mi> cal.i_ion 
</mi></mrow><mo>&#8722;</mo><mrow><mi> vc.i 
</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8801;</mo><mn> 0.0 
</mn></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi> l2.v 
</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mi> l2.i 
</mi></mrow><mo>/</mo><mrow><mi> l2.c 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> vc.within_pulse 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mi> time 
</mi></mrow><mo>&#8722;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.tp_last 
</mi></mrow><mo>)</mo></mrow></mrow></mrow><mo>&lt;</mo><mrow><mi> vc.d_pulse 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> vc.after_pulse 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mi> time 
</mi></mrow><mo>&#8722;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.tp_last 
</mi></mrow><mo>)</mo></mrow></mrow></mrow><mo>&gt;</mo><mrow><mi> vc.d_pulse 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition1 
</mi></mrow><mo>&#8801;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition2 
</mi></mrow><mo>&#8801;</mo><mrow><mi> vc.pulse_start 
</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition3 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>&#8800;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow><mo>&#8743;</mo><mrow><mi> vc.after_pulse 
</mi></mrow><mo>)</mo></mrow><mo>&#8744;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition4 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>&#8800;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow><mo>&#8743;</mo><mrow><mi> vc.within_pulse 
</mi></mrow><mo>)</mo></mrow><mo>&#8744;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow></mrow>
</math>
<li>Within group cal (prefix _ indicates shortened variable name)
<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_trans.rate</mi></mrow><mo>&#8801;</mo><mrow><mn> 1.03642695739058e-05 
</mn><mo>&sdot;</mo><mrow><mrow><mi>_trans.n</mi></mrow><mo>&sdot;</mo><mrow><mrow><mi>_i_ion</mi></mrow><mo>/</mo><mrow><mo>&#8475;</mo><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi>_trans.z</mi></mrow><mo>)</mo></mrow></mrow></mrow></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi>_act.n</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mi>_act.steady</mi></mrow><mo>&#8722;</mo><mrow><mi>_act.n</mi></mrow><mo>)</mo></mrow><mo>/</mo><mrow><mi>_act.tau</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi>_inact_slow.n</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mi>_inact_slow.steady</mi></mrow><mo>&#8722;</mo><mrow><mi>_inact_slow.n</mi></mrow><mo>)</mo></mrow><mo>/</mo><mrow><mi>_inact_slow.tau</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi>_inact_fast.n</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mi>_inact_fast.steady</mi></mrow><mo>&#8722;</mo><mrow><mi>_inact_fast.n</mi></mrow><mo>)</mo></mrow><mo>/</mo><mrow><mi>_inact_fast.tau</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_open_ratio</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_act.n</mi></mrow><mo>&sdot;</mo><mrow><mrow><mi>_inact_total</mi></mrow><mo>&sdot;</mo><mrow><mi>_ach_factor</mi></mrow></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_i_open</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_g_max</mi></mrow><mo>&sdot;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>&#8722;</mo><mrow><mi>_v_eq</mi></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_i_ion</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_open_ratio</mi></mrow><mo>&sdot;</mo><mrow><mi>_i_open</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_g</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_open_ratio</mi></mrow><mo>&sdot;</mo><mrow><mi>_g_max</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_act.steady</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>fsteady</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> -0.0032 
</mn><mo>,</mo><mn> 151.285930408472 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_act.tau</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>act.ftau</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact_slow.steady</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>fsteady</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> -0.029 
</mn><mo>,</mo><mn> -158.4786053882726 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact_slow.tau</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>inact_fast.ftau</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.06 
</mn><mo>,</mo><mn> 1.14171 
</mn><mo>,</mo><mn> -0.04 
</mn><mo>,</mo><mn> 0.008307827634225447 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact_fast.steady</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>fsteady</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> -0.029 
</mn><mo>,</mo><mn> -158.4786053882726 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact_fast.tau</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>inact_fast.ftau</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.01 
</mn><mo>,</mo><mn> 0.1639 
</mn><mo>,</mo><mn> -0.04 
</mn><mo>,</mo><mn> 0.009635092111651035 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact_total</mi></mrow><mo>&#8801;</mo><mrow><mrow><mn> 0.675 
</mn><mo>&sdot;</mo><mrow><mi>_inact_fast.n</mi></mrow></mrow><mo>+</mo><mrow><mn> 0.325 
</mn><mo>&sdot;</mo><mrow><mi>_inact_slow.n</mi></mrow></mrow></mrow></mrow>
</math>
</ol>

<li>Within group vc (prefix _ indicates shortened variable name)
<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mrow><mi>_g.p.i</mi></mrow><mo>+</mo><mrow><mo>(</mo><mrow><mi>_i</mi></mrow><mo>&#8722;</mo><mrow><mi>_n.i</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8801;</mo><mn> 0.0 
</mn></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_i</mi></mrow><mo>&#8801;</mo><mrow><mi>_n.i</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> l2.v 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mo>&#8475;</mo><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi>_pulse_signal</mi></mrow><mo>)</mo></mrow></mrow><mo>&sdot;</mo><mrow><mo>(</mo><mrow><mi>_v_pulse</mi></mrow><mo>&#8722;</mo><mrow><mi>_v_hold</mi></mrow><mo>)</mo></mrow></mrow><mo>+</mo><mrow><mi>_v_hold</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_pulse_start</mi></mrow><mo>&#8801;</mo><mrow><sample/><mo>&#8289;</mo><mrow><mo>(</mo><mn> 1 
</mn><mo>,</mo><mrow><mi>_d_hold</mi></mrow><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_pulse_end</mi></mrow><mo>&#8801;</mo><mrow><sample/><mo>&#8289;</mo><mrow><mo>(</mo><mn> 2 
</mn><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_peak_indicator</mi></mrow><mo>&#8801;</mo><mrow><mrow><msup><mrow><mrow><mi>_i</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#215;</mo><mn> 1000000000000.0 
</mn></mrow><mo>&lt;</mo><mn> 0.0 
</mn></mrow></mrow>
</math>
</ol>

</ol>
<p>Functions:</p><pre><code class="language-modelica">function fa
  input Real x &quot;input value&quot;;
  input Real x0 = -0.035 &quot;offset for x (fitting parameter)&quot;;
  input Real sy = 65.3 &quot;scaling factor for y (fitting parameter)&quot;;
  input Real sx = -400.0 &quot;scaling factor for x (fitting parameter)&quot;;
  output Real y &quot;result&quot;;
  protected Real x_adj &quot;adjusted x with offset and scaling factor&quot;;
algorithm
  x_adj := sx * (x - x0);
  if abs(x - x0) &lt; 1e-06 then
    y := sy;
  else
    y := sy * x_adj / (exp(x_adj) - 1.0);
  end if;
end fa;</code></pre><pre><code class="language-modelica">function fsteady
  input Real x &quot;input value&quot;;
  input Real y_min = 0.0 &quot;lower asymptote (fitting parameter)&quot;;
  input Real y_max = 1.0 &quot;upper asmyptote when d_off=1 and nu=1 (fititng parameter)&quot;;
  input Real x0 = -0.0032 &quot;x-value of sigmoid midpoint when d_off=1 and nu=1 (fitting parameter)&quot;;
  input Real sx = 151.285930408472 &quot;scaling factor for x axis (i.e. steepness, fitting parameter)&quot;;
  input Real se = 1.0 &quot;scaling factor for exponential part (fitting parameter)&quot;;
  input Real d_off = 1.0 &quot;offset in denominator (affects upper asymptote, fitting parameter)&quot;;
  input Real nu = 1.0 &quot;reciprocal of exponent of denominator (affects upper asymptote, fitting parameter)&quot;;
  output Real y &quot;result&quot;;
  protected Real x_adj &quot;adjusted x with offset and scaling factor&quot;;
algorithm
  x_adj := sx * (x - x0);
  y := y_min + (y_max - y_min) / (se * exp(-x_adj) + d_off) ^ (1.0 / nu);
end fsteady;</code></pre><pre><code class="language-modelica">function absmax &quot;returns input whose absolute value is larger, preserving the sign&quot;
  input Real a &quot;first input&quot;;
  input Real b &quot;second input&quot;;
  output Real m &quot;a if abs(a) &gt; abs(b), otherwise b&quot;;
algorithm
  m := if abs(a) &gt; abs(b) then a else b;
end absmax;</code></pre><pre><code class="language-modelica">function act.ftau
  input Real x &quot;input value&quot;;
  input Real off = 0.0 &quot;offset added to result to increase minimum (fitting parameter)&quot;;
  output Real y &quot;result of applying the HH-style equation tau = 1/(alpha + beta)&quot;;
algorithm
  y := 1.0 / (falpha(x) + fa(x, 0.005, 10.52 / 0.4, 400.0)) + off;
end act.ftau;</code></pre><pre><code class="language-modelica">function michaelisMenten &quot;equation for enzymatic reactions following Michaelis-Menten kinetics&quot;
  input Real s(quantity = &quot;Concentration&quot;, unit = &quot;mol/m3&quot;) &quot;substrate concentration&quot;;
  input Real k(quantity = &quot;Concentration&quot;, unit = &quot;mol/m3&quot;) &quot;concentration producing half-maximum reaction rate (michaelis constant)&quot;;
  output Real rate(unit = &quot;1&quot;) &quot;reaction rate&quot;;
algorithm
  rate := s / (s + k);
end michaelisMenten;</code></pre><pre><code class="language-modelica">function falpha
  input Real x &quot;input value&quot;;
  output Real y &quot;output value&quot;;
algorithm
  y := fa(x, -0.035, 26.12 * 2.5, -1000.0 / 2.5) + fa(x, 0.0, 78.11 / 0.208, -208.0);
end falpha;</code></pre><pre><code class="language-modelica">function inact_fast.ftau
  input Real x &quot;input value&quot;;
  input Real y_min = 0.01 &quot;minimum value achieved at edges (fitting parameter)&quot;;
  input Real y_max = 0.1639 &quot;maximum value achieved at peak (fititng parameter)&quot;;
  input Real x0 = -0.04 &quot;x-value of bell curve midpoint (fitting parameter)&quot;;
  input Real sigma = 0.009635092111651035 &quot;standard deviation determining the width of the bell curve (fitting parameter)&quot;;
  output Real y &quot;result&quot;;
  protected Real x_adj &quot;adjusted x with offset and standard deviation&quot;;
algorithm
  x_adj := (x - x0) / sigma;
  y := y_min + (y_max - y_min) * exp(-0.5 * x_adj ^ 2.0);
end inact_fast.ftau;</code></pre><table><tr><th style="text-align: right">name</th><th style="text-align: right">unit</th><th style="text-align: right">value</th><th style="text-align: right">label</th></tr><tr><td style="text-align: right">l2.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing from pin p to pin n</td></tr><tr><td style="text-align: right">l2.v</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right"></td><td style="text-align: right">Voltage drop of the two pins (= p.v - n.v)</td></tr><tr><td style="text-align: right">cal.inact_total</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right">cal.inact_fast.tau</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right"></td><td style="text-align: right">time constant for obtaining steady state (i.e. time until difference between n and steady has reduced by a factor of 1/e)</td></tr><tr><td style="text-align: right">cal.inact_fast.steady</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">value that n would reach if v_gate was held constant</td></tr><tr><td style="text-align: right">cal.inact_fast.n</td><td style="text-align: right"></td><td style="text-align: right">0.009992481708450124</td><td style="text-align: right">ratio of molecules in open conformation</td></tr><tr><td style="text-align: right">cal.inact_slow.tau</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right"></td><td style="text-align: right">time constant for obtaining steady state (i.e. time until difference between n and steady has reduced by a factor of 1/e)</td></tr><tr><td style="text-align: right">cal.inact_slow.steady</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">value that n would reach if v_gate was held constant</td></tr><tr><td style="text-align: right">cal.inact_slow.n</td><td style="text-align: right"></td><td style="text-align: right">0.009992481708450124</td><td style="text-align: right">ratio of molecules in open conformation</td></tr><tr><td style="text-align: right">cal.act.tau</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right"></td><td style="text-align: right">time constant for obtaining steady state (i.e. time until difference between n and steady has reduced by a factor of 1/e)</td></tr><tr><td style="text-align: right">cal.act.steady</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">value that n would reach if v_gate was held constant</td></tr><tr><td style="text-align: right">cal.act.n</td><td style="text-align: right"></td><td style="text-align: right">0.6187190947824258</td><td style="text-align: right">ratio of molecules in open conformation</td></tr><tr><td style="text-align: right">cal.trans.rate</td><td style="text-align: right">&quot;mol/s&quot;</td><td style="text-align: right"></td><td style="text-align: right">rate of change in substance amount</td></tr><tr><td style="text-align: right">cal.g</td><td style="text-align: right">&quot;S&quot;</td><td style="text-align: right"></td><td style="text-align: right">ion conductance</td></tr><tr><td style="text-align: right">cal.i_open</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">i if open_ratio = 1</td></tr><tr><td style="text-align: right">cal.open_ratio</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right"></td><td style="text-align: right">ratio between 0 (fully closed) and 1 (fully open)</td></tr><tr><td style="text-align: right">cal.i_ion</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">current used for ion flux</td></tr><tr><td style="text-align: right">vc.after_pulse</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">true after pulse has passed</td></tr><tr><td style="text-align: right">vc.within_pulse</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">true during pulse</td></tr><tr><td style="text-align: right">vc.vp_last</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">voltage of last pulse</td></tr><tr><td style="text-align: right">vc.tp_last</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">time stamp of start of last pulse</td></tr><tr><td style="text-align: right">vc.peak_indicator</td><td style="text-align: right"></td><td style="text-align: right">false</td><td style="text-align: right">forces event at peak (factor of 1e12 is required to detect zero crossing)</td></tr><tr><td style="text-align: right">vc.tail_i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">peak current after pulse</td></tr><tr><td style="text-align: right">vc.peak_i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">peak current during pulse</td></tr><tr><td style="text-align: right">vc.vs_tail</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_tail</td></tr><tr><td style="text-align: right">vc.vs_end</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_end</td></tr><tr><td style="text-align: right">vc.vs_peak</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_peak</td></tr><tr><td style="text-align: right">vc.is_end</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of current at end of last pulse</td></tr><tr><td style="text-align: right">vc.is_tail</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of peak tail current after last pulse</td></tr><tr><td style="text-align: right">vc.is_peak</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of peak current during last pulse</td></tr><tr><td style="text-align: right">vc.v_pulse</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right"></td><td style="text-align: right">voltage during pulse (must be defined externally)</td></tr><tr><td style="text-align: right">vc.pulse_signal</td><td style="text-align: right"></td><td style="text-align: right">0</td><td style="text-align: right">0 during holding period, 1 during pulse</td></tr><tr><td style="text-align: right">vc.pulse_end</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">signals end of pulse</td></tr><tr><td style="text-align: right">vc.pulse_start</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">signals start of pulse</td></tr><tr><td style="text-align: right">vc.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">measured membrane current</td></tr><tr><td style="text-align: right">vc.g.p.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing into the pin</td></tr><tr><td style="text-align: right">vc.n.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing into the pin</td></tr><tr><td style="text-align: right">$whenCondition1</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.pulse_end</td></tr><tr><td style="text-align: right">$whenCondition2</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.pulse_start</td></tr><tr><td style="text-align: right">$whenCondition3</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.peak_indicator &lt;&gt; pre(vc.peak_indicator) and vc.after_pulse or vc.pulse_end</td></tr><tr><td style="text-align: right">$whenCondition4</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.peak_indicator &lt;&gt; pre(vc.peak_indicator) and vc.within_pulse or vc.pulse_end</td></tr><tr><td style="text-align: right">cal.con.substance.amount</td><td style="text-align: right">&quot;mol&quot;</td><td style="text-align: right">cal.con.c_const * cal.con.vol</td><td style="text-align: right">amount of substance</td></tr><tr><td style="text-align: right">ca.substance.amount</td><td style="text-align: right">&quot;mol&quot;</td><td style="text-align: right">ca.c_const * ca.vol</td><td style="text-align: right">amount of substance</td></tr><tr><td style="text-align: right">vc.g.p.v</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">Potential at the pin</td></tr><tr><td style="text-align: right">cal.ach_factor</td><td style="text-align: right"></td><td style="text-align: right">if use_ach then 1.0 - cal.k_ach * InaMo.Functions.Biochemical.michaelisMenten(ach, 9.000000000000001e-05) else 1.0</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">vc.d_hold</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">5.0</td><td style="text-align: right">holding period</td></tr><tr><td style="text-align: right">vc.d_pulse</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">0.3</td><td style="text-align: right">pulse period</td></tr><tr><td style="text-align: right">vc.v_hold</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.07000000000000001</td><td style="text-align: right">voltage during holding period</td></tr><tr><td style="text-align: right">v_start</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.06</td><td style="text-align: right">start value for pulse amplitude</td></tr><tr><td style="text-align: right">v_inc</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.005</td><td style="text-align: right">increment for pulse amplitude</td></tr><tr><td style="text-align: right">v_sub</td><td style="text-align: right">&quot;m3&quot;</td><td style="text-align: right">1.0</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">use_ach</td><td style="text-align: right"></td><td style="text-align: right">false</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">ach</td><td style="text-align: right">&quot;mol/m3&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">ca_ex</td><td style="text-align: right">&quot;mol/m3&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">extracellular Ca2+ concentration (value not used in this simulation)</td></tr><tr><td style="text-align: right">cal.v_eq</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0621</td><td style="text-align: right">equilibrium potential</td></tr><tr><td style="text-align: right">cal.g_max</td><td style="text-align: right">&quot;S&quot;</td><td style="text-align: right">2.1e-08</td><td style="text-align: right">maximum conductance</td></tr><tr><td style="text-align: right">cal.trans.n</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right">cal.n_ca</td><td style="text-align: right">stoichiometric ratio of ion transport</td></tr><tr><td style="text-align: right">cal.trans.z</td><td style="text-align: right"></td><td style="text-align: right">2</td><td style="text-align: right">valence of ion</td></tr><tr><td style="text-align: right">cal.con.c_const</td><td style="text-align: right">&quot;mol/m3&quot;</td><td style="text-align: right">ca_ex</td><td style="text-align: right">fixed concentration</td></tr><tr><td style="text-align: right">cal.con.vol</td><td style="text-align: right">&quot;m3&quot;</td><td style="text-align: right">1.0</td><td style="text-align: right">volume of the compartment</td></tr><tr><td style="text-align: right">cal.n_ca</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right">1.0</td><td style="text-align: right">stoichiometric ratio of transport</td></tr><tr><td style="text-align: right">cal.current_name</td><td style="text-align: right"></td><td style="text-align: right">&quot;I_Ca,L&quot;</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">cal.k_ach</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">ratio of maximum channel inhibition by acetylcholine</td></tr><tr><td style="text-align: right">ca.c_const</td><td style="text-align: right">&quot;mol/m3&quot;</td><td style="text-align: right">1.0</td><td style="text-align: right">fixed concentration</td></tr><tr><td style="text-align: right">ca.vol</td><td style="text-align: right">&quot;m3&quot;</td><td style="text-align: right">v_sub</td><td style="text-align: right">volume of the compartment</td></tr><tr><td style="text-align: right">l2.c</td><td style="text-align: right">&quot;F&quot;</td><td style="text-align: right">4e-11</td><td style="text-align: right">membrane capacitance</td></tr><tr><td style="text-align: right">l2.v_init</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.09</td><td style="text-align: right">initial potential (from short initial stimulation)</td></tr><tr><td style="text-align: right">l2.use_init</td><td style="text-align: right"></td><td style="text-align: right">false</td><td style="text-align: right">determines whether initial value for v is used</td></tr></table>
    <p>This example uses the same settings as LTypeCalciumIV, but uses the
    equations for the N cell model instead of the AN/NH cell models.</p>
    <p>To reproduce Figure S1E from Inada 2009, plot vc.is_peak against
    vc.vs_peak.
    It is necessary to use vc.vs_peak instead of vc.v_pulse, because vc.is_peak
    captures the peak current from the <i>previous</i> pulse.</p>
    <p>All parameters are set to the same values as in LTypeCalciumIV with the
    same rationale.</p>
    <pre><code class="language-modelica">model LTypeCalciumIVN &quot;IV relationship of I_Ca,L, recreates Figure S1E of Inada 2009&quot;
  // FIXME redeclare breaks icon inheritance
  extends LTypeCalciumIV(redeclare InaMo.Currents.Atrioventricular.LTypeCalciumChannelN cal(g_max = 21e-9));
  annotation(
    experiment(StartTime = 0, StopTime = 164, Tolerance = 1e-6, Interval = 1e-2),
    __OpenModelica_simulationFlags(lv = &quot;LOG_STATS&quot;, s = &quot;dassl&quot;),
    __MoST_experiment(variableFilter = &quot;vc\\.(is_peak|vs_peak|v|v_pulse)&quot;),
    Documentation(info = &quot;
    &lt;html&gt;
    &lt;p&gt;This example uses the same settings as LTypeCalciumIV, but uses the
    equations for the N cell model instead of the AN/NH cell models.&lt;/p&gt;
    &lt;p&gt;To reproduce Figure S1E from Inada 2009, plot vc.is_peak against
    vc.vs_peak.
    It is necessary to use vc.vs_peak instead of vc.v_pulse, because vc.is_peak
    captures the peak current from the &lt;i&gt;previous&lt;/i&gt; pulse.&lt;/p&gt;
    &lt;p&gt;All parameters are set to the same values as in LTypeCalciumIV with the
    same rationale.&lt;/p&gt;
    &lt;/html&gt;
  &quot;));
end LTypeCalciumIVN;</code></pre><ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mrow><mi> l2.i 
</mi></mrow><mo>+</mo><mrow><mo>(</mo><mrow><mi> cal.i_ion 
</mi></mrow><mo>&#8722;</mo><mrow><mi> vc.i 
</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8801;</mo><mn> 0.0 
</mn></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi> l2.v 
</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mi> l2.i 
</mi></mrow><mo>/</mo><mrow><mi> l2.c 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> vc.within_pulse 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mi> time 
</mi></mrow><mo>&#8722;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.tp_last 
</mi></mrow><mo>)</mo></mrow></mrow></mrow><mo>&lt;</mo><mrow><mi> vc.d_pulse 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> vc.after_pulse 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mi> time 
</mi></mrow><mo>&#8722;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.tp_last 
</mi></mrow><mo>)</mo></mrow></mrow></mrow><mo>&gt;</mo><mrow><mi> vc.d_pulse 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition1 
</mi></mrow><mo>&#8801;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition2 
</mi></mrow><mo>&#8801;</mo><mrow><mi> vc.pulse_start 
</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition3 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>&#8800;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow><mo>&#8743;</mo><mrow><mi> vc.after_pulse 
</mi></mrow><mo>)</mo></mrow><mo>&#8744;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition4 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>&#8800;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow><mo>&#8743;</mo><mrow><mi> vc.within_pulse 
</mi></mrow><mo>)</mo></mrow><mo>&#8744;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow></mrow>
</math>
<li>Within group cal (prefix _ indicates shortened variable name)
<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_trans.rate</mi></mrow><mo>&#8801;</mo><mrow><mn> 1.03642695739058e-05 
</mn><mo>&sdot;</mo><mrow><mrow><mi>_trans.n</mi></mrow><mo>&sdot;</mo><mrow><mrow><mi>_i_ion</mi></mrow><mo>/</mo><mrow><mo>&#8475;</mo><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi>_trans.z</mi></mrow><mo>)</mo></mrow></mrow></mrow></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi>_act.n</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mi>_act.steady</mi></mrow><mo>&#8722;</mo><mrow><mi>_act.n</mi></mrow><mo>)</mo></mrow><mo>/</mo><mrow><mi>_act.tau</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi>_inact_slow.n</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mi>_inact_slow.steady</mi></mrow><mo>&#8722;</mo><mrow><mi>_inact_slow.n</mi></mrow><mo>)</mo></mrow><mo>/</mo><mrow><mi>_inact_slow.tau</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi>_inact_fast.n</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mi>_inact_fast.steady</mi></mrow><mo>&#8722;</mo><mrow><mi>_inact_fast.n</mi></mrow><mo>)</mo></mrow><mo>/</mo><mrow><mi>_inact_fast.tau</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_open_ratio</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_act.n</mi></mrow><mo>&sdot;</mo><mrow><mrow><mi>_inact_total</mi></mrow><mo>&sdot;</mo><mrow><mi>_ach_factor</mi></mrow></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_i_open</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_g_max</mi></mrow><mo>&sdot;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>&#8722;</mo><mrow><mi>_v_eq</mi></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_i_ion</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_open_ratio</mi></mrow><mo>&sdot;</mo><mrow><mi>_i_open</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_g</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_open_ratio</mi></mrow><mo>&sdot;</mo><mrow><mi>_g_max</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_act.steady</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>fsteady</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> -0.0182 
</mn><mo>,</mo><mn> 200.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_act.tau</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>act.ftau</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact_slow.steady</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>fsteady</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> -0.029 
</mn><mo>,</mo><mn> -158.4786053882726 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact_slow.tau</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>inact_fast.ftau</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.06 
</mn><mo>,</mo><mn> 1.14171 
</mn><mo>,</mo><mn> -0.04 
</mn><mo>,</mo><mn> 0.008307827634225447 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact_fast.steady</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>fsteady</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> -0.029 
</mn><mo>,</mo><mn> -158.4786053882726 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact_fast.tau</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>inact_fast.ftau</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.01 
</mn><mo>,</mo><mn> 0.1639 
</mn><mo>,</mo><mn> -0.04 
</mn><mo>,</mo><mn> 0.009635092111651035 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact_total</mi></mrow><mo>&#8801;</mo><mrow><mrow><mn> 0.675 
</mn><mo>&sdot;</mo><mrow><mi>_inact_fast.n</mi></mrow></mrow><mo>+</mo><mrow><mn> 0.325 
</mn><mo>&sdot;</mo><mrow><mi>_inact_slow.n</mi></mrow></mrow></mrow></mrow>
</math>
</ol>

<li>Within group vc (prefix _ indicates shortened variable name)
<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mrow><mi>_g.p.i</mi></mrow><mo>+</mo><mrow><mo>(</mo><mrow><mi>_i</mi></mrow><mo>&#8722;</mo><mrow><mi>_n.i</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8801;</mo><mn> 0.0 
</mn></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_i</mi></mrow><mo>&#8801;</mo><mrow><mi>_n.i</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> l2.v 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mo>&#8475;</mo><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi>_pulse_signal</mi></mrow><mo>)</mo></mrow></mrow><mo>&sdot;</mo><mrow><mo>(</mo><mrow><mi>_v_pulse</mi></mrow><mo>&#8722;</mo><mrow><mi>_v_hold</mi></mrow><mo>)</mo></mrow></mrow><mo>+</mo><mrow><mi>_v_hold</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_pulse_start</mi></mrow><mo>&#8801;</mo><mrow><sample/><mo>&#8289;</mo><mrow><mo>(</mo><mn> 1 
</mn><mo>,</mo><mrow><mi>_d_hold</mi></mrow><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_pulse_end</mi></mrow><mo>&#8801;</mo><mrow><sample/><mo>&#8289;</mo><mrow><mo>(</mo><mn> 2 
</mn><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_peak_indicator</mi></mrow><mo>&#8801;</mo><mrow><mrow><msup><mrow><mrow><mi>_i</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#215;</mo><mn> 1000000000000.0 
</mn></mrow><mo>&lt;</mo><mn> 0.0 
</mn></mrow></mrow>
</math>
</ol>

</ol>
<p>Functions:</p><pre><code class="language-modelica">function fa
  input Real x &quot;input value&quot;;
  input Real x0 = -0.035 &quot;offset for x (fitting parameter)&quot;;
  input Real sy = 65.3 &quot;scaling factor for y (fitting parameter)&quot;;
  input Real sx = -400.0 &quot;scaling factor for x (fitting parameter)&quot;;
  output Real y &quot;result&quot;;
  protected Real x_adj &quot;adjusted x with offset and scaling factor&quot;;
algorithm
  x_adj := sx * (x - x0);
  if abs(x - x0) &lt; 1e-06 then
    y := sy;
  else
    y := sy * x_adj / (exp(x_adj) - 1.0);
  end if;
end fa;</code></pre><pre><code class="language-modelica">function fsteady
  input Real x &quot;input value&quot;;
  input Real y_min = 0.0 &quot;lower asymptote (fitting parameter)&quot;;
  input Real y_max = 1.0 &quot;upper asmyptote when d_off=1 and nu=1 (fititng parameter)&quot;;
  input Real x0 = -0.0182 &quot;x-value of sigmoid midpoint when d_off=1 and nu=1 (fitting parameter)&quot;;
  input Real sx = 200.0 &quot;scaling factor for x axis (i.e. steepness, fitting parameter)&quot;;
  input Real se = 1.0 &quot;scaling factor for exponential part (fitting parameter)&quot;;
  input Real d_off = 1.0 &quot;offset in denominator (affects upper asymptote, fitting parameter)&quot;;
  input Real nu = 1.0 &quot;reciprocal of exponent of denominator (affects upper asymptote, fitting parameter)&quot;;
  output Real y &quot;result&quot;;
  protected Real x_adj &quot;adjusted x with offset and scaling factor&quot;;
algorithm
  x_adj := sx * (x - x0);
  y := y_min + (y_max - y_min) / (se * exp(-x_adj) + d_off) ^ (1.0 / nu);
end fsteady;</code></pre><pre><code class="language-modelica">function falpha
  input Real x &quot;input value&quot;;
  output Real y &quot;output value&quot;;
algorithm
  y := fa(x, -0.035, 26.12 * 2.5, -1000.0 / 2.5) + fa(x, 0.0, 78.11 / 0.208, -208.0);
end falpha;</code></pre><pre><code class="language-modelica">function act.ftau
  input Real x &quot;input value&quot;;
  input Real off = 0.0 &quot;offset added to result to increase minimum (fitting parameter)&quot;;
  output Real y &quot;result of applying the HH-style equation tau = 1/(alpha + beta)&quot;;
algorithm
  y := 1.0 / (falpha(x) + fa(x, 0.005, 10.52 / 0.4, 400.0)) + off;
end act.ftau;</code></pre><pre><code class="language-modelica">function absmax &quot;returns input whose absolute value is larger, preserving the sign&quot;
  input Real a &quot;first input&quot;;
  input Real b &quot;second input&quot;;
  output Real m &quot;a if abs(a) &gt; abs(b), otherwise b&quot;;
algorithm
  m := if abs(a) &gt; abs(b) then a else b;
end absmax;</code></pre><pre><code class="language-modelica">function michaelisMenten &quot;equation for enzymatic reactions following Michaelis-Menten kinetics&quot;
  input Real s(quantity = &quot;Concentration&quot;, unit = &quot;mol/m3&quot;) &quot;substrate concentration&quot;;
  input Real k(quantity = &quot;Concentration&quot;, unit = &quot;mol/m3&quot;) &quot;concentration producing half-maximum reaction rate (michaelis constant)&quot;;
  output Real rate(unit = &quot;1&quot;) &quot;reaction rate&quot;;
algorithm
  rate := s / (s + k);
end michaelisMenten;</code></pre><pre><code class="language-modelica">function inact_fast.ftau
  input Real x &quot;input value&quot;;
  input Real y_min = 0.01 &quot;minimum value achieved at edges (fitting parameter)&quot;;
  input Real y_max = 0.1639 &quot;maximum value achieved at peak (fititng parameter)&quot;;
  input Real x0 = -0.04 &quot;x-value of bell curve midpoint (fitting parameter)&quot;;
  input Real sigma = 0.009635092111651035 &quot;standard deviation determining the width of the bell curve (fitting parameter)&quot;;
  output Real y &quot;result&quot;;
  protected Real x_adj &quot;adjusted x with offset and standard deviation&quot;;
algorithm
  x_adj := (x - x0) / sigma;
  y := y_min + (y_max - y_min) * exp(-0.5 * x_adj ^ 2.0);
end inact_fast.ftau;</code></pre><table><tr><th style="text-align: right">name</th><th style="text-align: right">unit</th><th style="text-align: right">value</th><th style="text-align: right">label</th></tr><tr><td style="text-align: right">l2.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing from pin p to pin n</td></tr><tr><td style="text-align: right">l2.v</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right"></td><td style="text-align: right">Voltage drop of the two pins (= p.v - n.v)</td></tr><tr><td style="text-align: right">cal.inact_total</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right">cal.inact_fast.tau</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right"></td><td style="text-align: right">time constant for obtaining steady state (i.e. time until difference between n and steady has reduced by a factor of 1/e)</td></tr><tr><td style="text-align: right">cal.inact_fast.steady</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">value that n would reach if v_gate was held constant</td></tr><tr><td style="text-align: right">cal.inact_fast.n</td><td style="text-align: right"></td><td style="text-align: right">0.009992481708450124</td><td style="text-align: right">ratio of molecules in open conformation</td></tr><tr><td style="text-align: right">cal.inact_slow.tau</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right"></td><td style="text-align: right">time constant for obtaining steady state (i.e. time until difference between n and steady has reduced by a factor of 1/e)</td></tr><tr><td style="text-align: right">cal.inact_slow.steady</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">value that n would reach if v_gate was held constant</td></tr><tr><td style="text-align: right">cal.inact_slow.n</td><td style="text-align: right"></td><td style="text-align: right">0.009992481708450124</td><td style="text-align: right">ratio of molecules in open conformation</td></tr><tr><td style="text-align: right">cal.act.tau</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right"></td><td style="text-align: right">time constant for obtaining steady state (i.e. time until difference between n and steady has reduced by a factor of 1/e)</td></tr><tr><td style="text-align: right">cal.act.steady</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">value that n would reach if v_gate was held constant</td></tr><tr><td style="text-align: right">cal.act.n</td><td style="text-align: right"></td><td style="text-align: right">0.9744192116879924</td><td style="text-align: right">ratio of molecules in open conformation</td></tr><tr><td style="text-align: right">cal.trans.rate</td><td style="text-align: right">&quot;mol/s&quot;</td><td style="text-align: right"></td><td style="text-align: right">rate of change in substance amount</td></tr><tr><td style="text-align: right">cal.g</td><td style="text-align: right">&quot;S&quot;</td><td style="text-align: right"></td><td style="text-align: right">ion conductance</td></tr><tr><td style="text-align: right">cal.i_open</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">i if open_ratio = 1</td></tr><tr><td style="text-align: right">cal.open_ratio</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right"></td><td style="text-align: right">ratio between 0 (fully closed) and 1 (fully open)</td></tr><tr><td style="text-align: right">cal.i_ion</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">current used for ion flux</td></tr><tr><td style="text-align: right">vc.after_pulse</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">true after pulse has passed</td></tr><tr><td style="text-align: right">vc.within_pulse</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">true during pulse</td></tr><tr><td style="text-align: right">vc.vp_last</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">voltage of last pulse</td></tr><tr><td style="text-align: right">vc.tp_last</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">time stamp of start of last pulse</td></tr><tr><td style="text-align: right">vc.peak_indicator</td><td style="text-align: right"></td><td style="text-align: right">false</td><td style="text-align: right">forces event at peak (factor of 1e12 is required to detect zero crossing)</td></tr><tr><td style="text-align: right">vc.tail_i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">peak current after pulse</td></tr><tr><td style="text-align: right">vc.peak_i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">peak current during pulse</td></tr><tr><td style="text-align: right">vc.vs_tail</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_tail</td></tr><tr><td style="text-align: right">vc.vs_end</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_end</td></tr><tr><td style="text-align: right">vc.vs_peak</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_peak</td></tr><tr><td style="text-align: right">vc.is_end</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of current at end of last pulse</td></tr><tr><td style="text-align: right">vc.is_tail</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of peak tail current after last pulse</td></tr><tr><td style="text-align: right">vc.is_peak</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of peak current during last pulse</td></tr><tr><td style="text-align: right">vc.v_pulse</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right"></td><td style="text-align: right">voltage during pulse (must be defined externally)</td></tr><tr><td style="text-align: right">vc.pulse_signal</td><td style="text-align: right"></td><td style="text-align: right">0</td><td style="text-align: right">0 during holding period, 1 during pulse</td></tr><tr><td style="text-align: right">vc.pulse_end</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">signals end of pulse</td></tr><tr><td style="text-align: right">vc.pulse_start</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">signals start of pulse</td></tr><tr><td style="text-align: right">vc.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">measured membrane current</td></tr><tr><td style="text-align: right">vc.g.p.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing into the pin</td></tr><tr><td style="text-align: right">vc.n.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing into the pin</td></tr><tr><td style="text-align: right">$whenCondition1</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.pulse_end</td></tr><tr><td style="text-align: right">$whenCondition2</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.pulse_start</td></tr><tr><td style="text-align: right">$whenCondition3</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.peak_indicator &lt;&gt; pre(vc.peak_indicator) and vc.after_pulse or vc.pulse_end</td></tr><tr><td style="text-align: right">$whenCondition4</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.peak_indicator &lt;&gt; pre(vc.peak_indicator) and vc.within_pulse or vc.pulse_end</td></tr><tr><td style="text-align: right">cal.con.substance.amount</td><td style="text-align: right">&quot;mol&quot;</td><td style="text-align: right">cal.con.c_const * cal.con.vol</td><td style="text-align: right">amount of substance</td></tr><tr><td style="text-align: right">ca.substance.amount</td><td style="text-align: right">&quot;mol&quot;</td><td style="text-align: right">ca.c_const * ca.vol</td><td style="text-align: right">amount of substance</td></tr><tr><td style="text-align: right">vc.g.p.v</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">Potential at the pin</td></tr><tr><td style="text-align: right">cal.ach_factor</td><td style="text-align: right"></td><td style="text-align: right">if use_ach then 1.0 - cal.k_ach * InaMo.Functions.Biochemical.michaelisMenten(ach, 9.000000000000001e-05) else 1.0</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">vc.d_hold</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">5.0</td><td style="text-align: right">holding period</td></tr><tr><td style="text-align: right">vc.d_pulse</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">0.3</td><td style="text-align: right">pulse period</td></tr><tr><td style="text-align: right">vc.v_hold</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.07000000000000001</td><td style="text-align: right">voltage during holding period</td></tr><tr><td style="text-align: right">v_start</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.06</td><td style="text-align: right">start value for pulse amplitude</td></tr><tr><td style="text-align: right">v_inc</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.005</td><td style="text-align: right">increment for pulse amplitude</td></tr><tr><td style="text-align: right">v_sub</td><td style="text-align: right">&quot;m3&quot;</td><td style="text-align: right">1.0</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">use_ach</td><td style="text-align: right"></td><td style="text-align: right">false</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">ach</td><td style="text-align: right">&quot;mol/m3&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">ca_ex</td><td style="text-align: right">&quot;mol/m3&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">extracellular Ca2+ concentration (value not used in this simulation)</td></tr><tr><td style="text-align: right">cal.v_eq</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0621</td><td style="text-align: right">equilibrium potential</td></tr><tr><td style="text-align: right">cal.g_max</td><td style="text-align: right">&quot;S&quot;</td><td style="text-align: right">2.1e-08</td><td style="text-align: right">maximum conductance</td></tr><tr><td style="text-align: right">cal.trans.n</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right">cal.n_ca</td><td style="text-align: right">stoichiometric ratio of ion transport</td></tr><tr><td style="text-align: right">cal.trans.z</td><td style="text-align: right"></td><td style="text-align: right">2</td><td style="text-align: right">valence of ion</td></tr><tr><td style="text-align: right">cal.con.c_const</td><td style="text-align: right">&quot;mol/m3&quot;</td><td style="text-align: right">ca_ex</td><td style="text-align: right">fixed concentration</td></tr><tr><td style="text-align: right">cal.con.vol</td><td style="text-align: right">&quot;m3&quot;</td><td style="text-align: right">1.0</td><td style="text-align: right">volume of the compartment</td></tr><tr><td style="text-align: right">cal.n_ca</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right">1.0</td><td style="text-align: right">stoichiometric ratio of transport</td></tr><tr><td style="text-align: right">cal.current_name</td><td style="text-align: right"></td><td style="text-align: right">&quot;I_Ca,L&quot;</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">cal.k_ach</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">ratio of maximum channel inhibition by acetylcholine</td></tr><tr><td style="text-align: right">ca.c_const</td><td style="text-align: right">&quot;mol/m3&quot;</td><td style="text-align: right">1.0</td><td style="text-align: right">fixed concentration</td></tr><tr><td style="text-align: right">ca.vol</td><td style="text-align: right">&quot;m3&quot;</td><td style="text-align: right">v_sub</td><td style="text-align: right">volume of the compartment</td></tr><tr><td style="text-align: right">l2.c</td><td style="text-align: right">&quot;F&quot;</td><td style="text-align: right">4e-11</td><td style="text-align: right">membrane capacitance</td></tr><tr><td style="text-align: right">l2.v_init</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.09</td><td style="text-align: right">initial potential (from short initial stimulation)</td></tr><tr><td style="text-align: right">l2.use_init</td><td style="text-align: right"></td><td style="text-align: right">false</td><td style="text-align: right">determines whether initial value for v is used</td></tr></table>
      <p>To reproduce Figure S1A and S1B from Inada 2009, plot act_steady and
      inact_steady against v.
      For Figure S1C and S1D, plot inact_tau_fast and inact_tau_slow
      against v.</p>
      <p>Simulation protocol and parameters are chosen with the following
      rationale:</p>
      <ul>
        <li>StopTime: allow a plot from -80 to 60 mV</li>
        <li>Tolerance: left at default value, since derivatives are not
        relevant</li>
        <li>Interval: enough for a smooth plot</li>
      </ul>
    <pre><code class="language-modelica">model LTypeCalciumSteady &quot;steady state of I_Ca,L, recreates Figures S1A-S1D from Inada 2009&quot;
  extends Modelica.Icons.Example;
  extends InaMo.Concentrations.Interfaces.CaConst;
  extends InaMo.Concentrations.Interfaces.NoACh;
  inner parameter SI.Concentration ca_ex = 0 &quot;extracellular Ca2+ concentration (value not used in this simulation)&quot;;
  InaMo.Membrane.LipidBilayer l2(use_init = false) &quot;cell membrane&quot; annotation(
    Placement(transformation(extent = {{17, -17}, {51, 17}})));
  InaMo.ExperimentalMethods.VoltageClamp.VoltageClamp vc &quot;voltage clamp&quot; annotation(
    Placement(transformation(extent = {{-17, -17}, {17, 17}})));
  InaMo.Currents.Atrioventricular.LTypeCalciumChannel cal &quot;I_Ca,L (AN and NH cells)&quot; annotation(
    Placement(transformation(extent = {{-51, -17}, {-17, 17}})));
  InaMo.Currents.Atrioventricular.LTypeCalciumChannelN calN &quot;I_Ca,L (N cell)&quot; annotation(
    Placement(transformation(extent = {{-85, -17}, {-51, 17}})));
  InaMo.Concentrations.Basic.ConstantConcentration ca(c_const = 0, vol = 0) &quot;dummy Ca2+ concentration required to avoid underdetermined equation system&quot; annotation(
    Placement(transformation(extent = {{-51, -80}, {-17, -46}})));
  Real act_steady = cal.act.steady &quot;steady state of activation gate (AN and NH cells)&quot;;
  Real act_steady_n = calN.act.steady &quot;steady state of activation gate (N cell)&quot;;
  SI.Duration act_tau = cal.act.tau &quot;time constant of activation gate&quot;;
  Real inact_steady = cal.inact_slow.steady &quot;steady state of inactivation gates&quot;;
  SI.Duration inact_tau_fast = cal.inact_fast.tau &quot;time constant of fast inactivation gate&quot;;
  SI.Duration inact_tau_slow = cal.inact_slow.tau &quot;time constant of slow inactivation gate&quot;;
  SI.Voltage v(start = -0.08, fixed = true) &quot;input voltage&quot;;
equation
  vc.v_stim = v;
  der(v) = 0.001;
  connect(l2.p, vc.p) annotation(
    Line(points = {{34, 18}, {34, 18}, {34, 40}, {0, 40}, {0, 18}, {0, 18}}, color = {0, 0, 255}));
  connect(l2.n, vc.n) annotation(
    Line(points = {{34, -16}, {34, -16}, {34, -40}, {0, -40}, {0, -16}, {0, -16}}, color = {0, 0, 255}));
  connect(vc.n, cal.n) annotation(
    Line(points = {{0, -16}, {0, -16}, {0, -40}, {-34, -40}, {-34, -16}, {-34, -16}}, color = {0, 0, 255}));
  connect(cal.n, calN.n) annotation(
    Line(points = {{-34, -16}, {-34, -16}, {-34, -40}, {-68, -40}, {-68, -16}, {-68, -16}}, color = {0, 0, 255}));
  connect(vc.p, cal.p) annotation(
    Line(points = {{0, 18}, {0, 18}, {0, 40}, {-34, 40}, {-34, 18}, {-34, 18}}, color = {0, 0, 255}));
  connect(cal.p, calN.p) annotation(
    Line(points = {{-34, 18}, {-34, 18}, {-34, 40}, {-68, 40}, {-68, 18}, {-68, 18}}, color = {0, 0, 255}));
  connect(ca.substance, cal.ca) annotation(
    Line(points = {{-34, -80}, {-12, -80}, {-12, -30}, {-28, -30}, {-28, -16}, {-28, -16}}));
  connect(ca.substance, calN.ca) annotation(
    Line(points = {{-34, -80}, {-62, -80}, {-62, -16}, {-62, -16}}));
  annotation(
    experiment(StartTime = 0, StopTime = 140, Tolerance = 1e-6, Interval = 1),
    __OpenModelica_simulationFlags(lv = &quot;LOG_STATS&quot;, s = &quot;dassl&quot;),
    __MoST_experiment(variableFilter = &quot;act_steady|inact_steady|act_steady_n|act_tau|inact_tau_fast|inact_tau_slow|v|vc\\.v&quot;),
    Documentation(info = &quot;
    &lt;html&gt;
      &lt;p&gt;To reproduce Figure S1A and S1B from Inada 2009, plot act_steady and
      inact_steady against v.
      For Figure S1C and S1D, plot inact_tau_fast and inact_tau_slow
      against v.&lt;/p&gt;
      &lt;p&gt;Simulation protocol and parameters are chosen with the following
      rationale:&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;StopTime: allow a plot from -80 to 60 mV&lt;/li&gt;
        &lt;li&gt;Tolerance: left at default value, since derivatives are not
        relevant&lt;/li&gt;
        &lt;li&gt;Interval: enough for a smooth plot&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/html&gt;
  &quot;));
end LTypeCalciumSteady;</code></pre><h2 id="Tests-for-I_{K,r}"><a class="docs-heading-anchor" href="#Tests-for-I_{K,r}">Tests for <span>$I_{K,r}$</span></a><a id="Tests-for-I_{K,r}-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-for-I_{K,r}" title="Permalink"></a></h2>
    <html>
    <p>To reproduce Figure S3C from Inada 2009, plot vc.is_end against
    vc.vs_end.
    To reproduce Figure S3D from Inada 2009, plot vc.is_tail against
    vc.vs_tail.
    It is necessary to use vc.vs_end/vc.vs_tail instead of vc.v_pulse,
    because vc.is_end and vc.is_tail capture the current from the
    <i>previous</i> pulse.</p>
    <p>To reproduce Figure S3E from Inada 2009, plot vc.i against time starting
    5 ms before and ending 500ms after the pulses with amplitude -10 mV, 10 mV
    and 30 mV.</p>
    <p>Simulation protocol and parameters are chosen with the following
    rationale:</p>
    <ul>
      <li>StopTime: allow a plot from -40 mV to 60 mV</li>
      <li>Tolerance: default value</li>
      <li>d_pulse: according to description of Figure S3 in Inada 2009</li>
      <li>d_hold: approximately 5 * max(inact.tau)</li>
      <li>v_hold: according to description of Figure S3 in Inada 2009</li>
      <li>l2.C: according to Table S15 in Inada 2009 (AN cell model)</li>
      <li>g_max: according to Table S15 in Inada 2009 (AN cell model)</li>
    </ul>
    <p>NOTE: IV-curve in S3C seem to be shifted by 5 mV towards lower
    voltages.
    This could be explained if Inada et al. accidentally associated currents
    with the newly started pulse right after the current was measured instead
    of the previous pulse.</p>
  <pre><code class="language-modelica">model RapidDelayedRectifierIV &quot;IV relationship of I_K,r, recreates Figure S3C-S3E&quot;
  extends InaMo.Examples.Interfaces.IVBase(vc(v_hold = -0.04, d_hold = 5, d_pulse = 0.5), v_start = -0.04, v_inc = 0.005);
  extends Modelica.Icons.Example;
  parameter SI.Concentration k_in = 140 &quot;intracellular potassium concentration&quot;;
  parameter SI.Concentration k_ex = 5.4 &quot;extracellular potassium concentration&quot;;
  parameter SI.Temperature temp = 310 &quot;cell medium temperature&quot;;
  parameter SI.Voltage v_k = nernst(k_in, k_ex, 1, temp) &quot;equilibrium potential for K+ ions&quot;;
  InaMo.Currents.Atrioventricular.RapidDelayedRectifierChannel kr(g_max = 1.5e-9, v_eq = v_k) &quot;I_K,r channel with parameters of AN cell model&quot; annotation(
    Placement(transformation(extent = {{-51, -17}, {-17, 17}})));
  InaMo.Membrane.LipidBilayer l2(use_init = false, c = 40e-12) &quot;cell membrane&quot; annotation(
    Placement(transformation(extent = {{17, -17}, {51, 17}})));
equation
  connect(l2.p, vc.p) annotation(
    Line(points = {{34, 18}, {34, 18}, {34, 40}, {0, 40}, {0, 18}, {0, 18}}, color = {0, 0, 255}));
  connect(vc.p, kr.p) annotation(
    Line(points = {{0, 18}, {0, 18}, {0, 40}, {-34, 40}, {-34, 18}, {-34, 18}}, color = {0, 0, 255}));
  connect(l2.n, vc.n) annotation(
    Line(points = {{34, -16}, {34, -16}, {34, -40}, {0, -40}, {0, -16}, {0, -16}}, color = {0, 0, 255}));
  connect(vc.n, kr.n) annotation(
    Line(points = {{0, -16}, {0, -16}, {0, -40}, {-34, -40}, {-34, -16}, {-34, -16}}, color = {0, 0, 255}));
  annotation(
    experiment(StartTime = 0, StopTime = 126, Tolerance = 1e-12, Interval = 1e-2),
    __OpenModelica_simulationFlags(lv = &quot;LOG_STATS&quot;, s = &quot;dassl&quot;),
    __MoST_experiment(variableFilter = &quot;vc\\.(is_end|vs_end|is_tail|vs_tail|is_peak|vs_peak|i|v|v_pulse)&quot;),
    Documentation(info = &quot;
    &lt;html&gt;
    &lt;p&gt;To reproduce Figure S3C from Inada 2009, plot vc.is_end against
    vc.vs_end.
    To reproduce Figure S3D from Inada 2009, plot vc.is_tail against
    vc.vs_tail.
    It is necessary to use vc.vs_end/vc.vs_tail instead of vc.v_pulse,
    because vc.is_end and vc.is_tail capture the current from the
    &lt;i&gt;previous&lt;/i&gt; pulse.&lt;/p&gt;
    &lt;p&gt;To reproduce Figure S3E from Inada 2009, plot vc.i against time starting
    5 ms before and ending 500ms after the pulses with amplitude -10 mV, 10 mV
    and 30 mV.&lt;/p&gt;
    &lt;p&gt;Simulation protocol and parameters are chosen with the following
    rationale:&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;StopTime: allow a plot from -40 mV to 60 mV&lt;/li&gt;
      &lt;li&gt;Tolerance: default value&lt;/li&gt;
      &lt;li&gt;d_pulse: according to description of Figure S3 in Inada 2009&lt;/li&gt;
      &lt;li&gt;d_hold: approximately 5 * max(inact.tau)&lt;/li&gt;
      &lt;li&gt;v_hold: according to description of Figure S3 in Inada 2009&lt;/li&gt;
      &lt;li&gt;l2.C: according to Table S15 in Inada 2009 (AN cell model)&lt;/li&gt;
      &lt;li&gt;g_max: according to Table S15 in Inada 2009 (AN cell model)&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;NOTE: IV-curve in S3C seem to be shifted by 5 mV towards lower
    voltages.
    This could be explained if Inada et al. accidentally associated currents
    with the newly started pulse right after the current was measured instead
    of the previous pulse.&lt;/p&gt;
  &quot;));
end RapidDelayedRectifierIV;</code></pre><ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mrow><mi> l2.i 
</mi></mrow><mo>+</mo><mrow><mo>(</mo><mrow><mi> kr.i_ion 
</mi></mrow><mo>&#8722;</mo><mrow><mi> vc.i 
</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8801;</mo><mn> 0.0 
</mn></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi> l2.v 
</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mi> l2.i 
</mi></mrow><mo>/</mo><mrow><mi> l2.c 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> vc.within_pulse 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mi> time 
</mi></mrow><mo>&#8722;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.tp_last 
</mi></mrow><mo>)</mo></mrow></mrow></mrow><mo>&lt;</mo><mrow><mi> vc.d_pulse 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> vc.after_pulse 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mi> time 
</mi></mrow><mo>&#8722;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.tp_last 
</mi></mrow><mo>)</mo></mrow></mrow></mrow><mo>&gt;</mo><mrow><mi> vc.d_pulse 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition1 
</mi></mrow><mo>&#8801;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition2 
</mi></mrow><mo>&#8801;</mo><mrow><mi> vc.pulse_start 
</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition3 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>&#8800;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow><mo>&#8743;</mo><mrow><mi> vc.after_pulse 
</mi></mrow><mo>)</mo></mrow><mo>&#8744;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition4 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>&#8800;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow><mo>&#8743;</mo><mrow><mi> vc.within_pulse 
</mi></mrow><mo>)</mo></mrow><mo>&#8744;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow></mrow>
</math>
<li>Within group kr (prefix _ indicates shortened variable name)
<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi>_act_fast.n</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mi>_act_fast.steady</mi></mrow><mo>&#8722;</mo><mrow><mi>_act_fast.n</mi></mrow><mo>)</mo></mrow><mo>/</mo><mrow><mi>_act_fast.tau</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi>_act_slow.n</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mi>_act_slow.steady</mi></mrow><mo>&#8722;</mo><mrow><mi>_act_slow.n</mi></mrow><mo>)</mo></mrow><mo>/</mo><mrow><mi>_act_slow.tau</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi>_inact.n</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mi>_inact.steady</mi></mrow><mo>&#8722;</mo><mrow><mi>_inact.n</mi></mrow><mo>)</mo></mrow><mo>/</mo><mrow><mi>_inact.tau</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_open_ratio</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_act_total</mi></mrow><mo>&sdot;</mo><mrow><mi>_inact.n</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_i_open</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_g_max</mi></mrow><mo>&sdot;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>&#8722;</mo><mrow><mi>_v_eq</mi></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_i_ion</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_open_ratio</mi></mrow><mo>&sdot;</mo><mrow><mi>_i_open</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_g</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_open_ratio</mi></mrow><mo>&sdot;</mo><mrow><mi>_g_max</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_act_fast.steady</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>act_fast.fsteady</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> -0.01022 
</mn><mo>,</mo><mn> 117.6470588235294 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_act_fast.tau</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>act_fast.ftau</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_act_slow.steady</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>act_fast.fsteady</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> -0.01022 
</mn><mo>,</mo><mn> 117.6470588235294 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_act_slow.tau</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>act_slow.ftau</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.33581 
</mn><mo>,</mo><mn> 1.24254 
</mn><mo>,</mo><mn> -0.01 
</mn><mo>,</mo><mn> 0.02222667316536598 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact.steady</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>inact.fsteady</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact.tau</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>inact.ftau</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_act_total</mi></mrow><mo>&#8801;</mo><mrow><mrow><mn> 0.9 
</mn><mo>&sdot;</mo><mrow><mi>_act_fast.n</mi></mrow></mrow><mo>+</mo><mrow><mn> 0.1 
</mn><mo>&sdot;</mo><mrow><mi>_act_slow.n</mi></mrow></mrow></mrow></mrow>
</math>
</ol>

<li>Within group vc (prefix _ indicates shortened variable name)
<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mrow><mi>_g.p.i</mi></mrow><mo>+</mo><mrow><mo>(</mo><mrow><mi>_i</mi></mrow><mo>&#8722;</mo><mrow><mi>_n.i</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8801;</mo><mn> 0.0 
</mn></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_i</mi></mrow><mo>&#8801;</mo><mrow><mi>_n.i</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> l2.v 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mo>&#8475;</mo><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi>_pulse_signal</mi></mrow><mo>)</mo></mrow></mrow><mo>&sdot;</mo><mrow><mo>(</mo><mrow><mi>_v_pulse</mi></mrow><mo>&#8722;</mo><mrow><mi>_v_hold</mi></mrow><mo>)</mo></mrow></mrow><mo>+</mo><mrow><mi>_v_hold</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_pulse_start</mi></mrow><mo>&#8801;</mo><mrow><sample/><mo>&#8289;</mo><mrow><mo>(</mo><mn> 1 
</mn><mo>,</mo><mrow><mi>_d_hold</mi></mrow><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_pulse_end</mi></mrow><mo>&#8801;</mo><mrow><sample/><mo>&#8289;</mo><mrow><mo>(</mo><mn> 2 
</mn><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_peak_indicator</mi></mrow><mo>&#8801;</mo><mrow><mrow><msup><mrow><mrow><mi>_i</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#215;</mo><mn> 1000000000000.0 
</mn></mrow><mo>&lt;</mo><mn> 0.0 
</mn></mrow></mrow>
</math>
</ol>

</ol>
<p>Functions:</p><pre><code class="language-modelica">function inact.ftau
  input Real x &quot;input value&quot;;
  input Real off = 0.0 &quot;offset added to result to increase minimum (fitting parameter)&quot;;
  output Real y &quot;result of applying the HH-style equation tau = 1/(alpha + beta)&quot;;
algorithm
  y := 1.0 / (falpha(x, 0.0, 9.42, 603.6) + falpha(x, 0.0, -18.3, 92.01000000000001)) + off;
end inact.ftau;</code></pre><pre><code class="language-modelica">function act_fast.fsteady
  input Real x &quot;input value&quot;;
  input Real y_min = 0.0 &quot;lower asymptote (fitting parameter)&quot;;
  input Real y_max = 1.0 &quot;upper asmyptote when d_off=1 and nu=1 (fititng parameter)&quot;;
  input Real x0 = -0.01022 &quot;x-value of sigmoid midpoint when d_off=1 and nu=1 (fitting parameter)&quot;;
  input Real sx = 117.6470588235294 &quot;scaling factor for x axis (i.e. steepness, fitting parameter)&quot;;
  input Real se = 1.0 &quot;scaling factor for exponential part (fitting parameter)&quot;;
  input Real d_off = 1.0 &quot;offset in denominator (affects upper asymptote, fitting parameter)&quot;;
  input Real nu = 1.0 &quot;reciprocal of exponent of denominator (affects upper asymptote, fitting parameter)&quot;;
  output Real y &quot;result&quot;;
  protected Real x_adj &quot;adjusted x with offset and scaling factor&quot;;
algorithm
  x_adj := sx * (x - x0);
  y := y_min + (y_max - y_min) / (se * exp(-x_adj) + d_off) ^ (1.0 / nu);
end act_fast.fsteady;</code></pre><pre><code class="language-modelica">function nernst &quot;Nernst equation to find the equlibrium potential for a single ion&quot;
  input Real ion_in(quantity = &quot;Concentration&quot;, unit = &quot;mol/m3&quot;) &quot;intracellular ion concentration&quot;;
  input Real ion_ex(quantity = &quot;Concentration&quot;, unit = &quot;mol/m3&quot;) &quot;extracellular ion concentration&quot;;
  input Integer ion_z &quot;valence of ion&quot;;
  input Real temp(quantity = &quot;ThermodynamicTemperature&quot;, unit = &quot;K&quot;, displayUnit = &quot;degC&quot;, min = 0.0, start = 288.15, nominal = 300.0) &quot;cell medium temperature&quot;;
  output Real v_eq(quantity = &quot;ElectricPotential&quot;, unit = &quot;V&quot;) &quot;equlibirium potential&quot;;
algorithm
  v_eq := 8.3144598 * temp / /*Real*/(ion_z) / 96485.33289000001 * log(ion_ex / ion_in);
end nernst;</code></pre><pre><code class="language-modelica">function inact.fsteady
  input Real x &quot;input value&quot;;
  output Real y &quot;output value&quot;;
algorithm
  y := act_fast.fsteady(x, 0.0, 1.0, -0.0049, -1000.0 / 15.14, 1.0, 1.0, 1.0) * act_slow.ftau(x, 1.0, (-0.3) + 1.0, 0.0, sqrt(500.0 / 2.0) / 1000.0);
end inact.fsteady;</code></pre><pre><code class="language-modelica">function absmax &quot;returns input whose absolute value is larger, preserving the sign&quot;
  input Real a &quot;first input&quot;;
  input Real b &quot;second input&quot;;
  output Real m &quot;a if abs(a) &gt; abs(b), otherwise b&quot;;
algorithm
  m := if abs(a) &gt; abs(b) then a else b;
end absmax;</code></pre><pre><code class="language-modelica">function falpha
  input Real x &quot;input value&quot;;
  input Real x0 = 0.0 &quot;x-value where y = 1 (fitting parameter)&quot;;
  input Real sx = 39.8 &quot;scaling factor for x axis (fitting parameter)&quot;;
  input Real sy = 17.0 &quot;scaling factor for y axis (fitting parameter)&quot;;
  output Real y &quot;result&quot;;
algorithm
  y := sy * exp(sx * (x - x0));
end falpha;</code></pre><pre><code class="language-modelica">function act_fast.ftau
  input Real x &quot;input value&quot;;
  input Real off = 0.0 &quot;offset added to result to increase minimum (fitting parameter)&quot;;
  output Real y &quot;result of applying the HH-style equation tau = 1/(alpha + beta)&quot;;
algorithm
  y := 1.0 / (falpha(x, 0.0, 39.8, 17.0) + falpha(x, 0.0, -51.0, 0.211)) + off;
end act_fast.ftau;</code></pre><pre><code class="language-modelica">function act_slow.ftau
  input Real x &quot;input value&quot;;
  input Real y_min = 0.33581 &quot;minimum value achieved at edges (fitting parameter)&quot;;
  input Real y_max = 1.24254 &quot;maximum value achieved at peak (fititng parameter)&quot;;
  input Real x0 = -0.01 &quot;x-value of bell curve midpoint (fitting parameter)&quot;;
  input Real sigma = 0.02222667316536598 &quot;standard deviation determining the width of the bell curve (fitting parameter)&quot;;
  output Real y &quot;result&quot;;
  protected Real x_adj &quot;adjusted x with offset and standard deviation&quot;;
algorithm
  x_adj := (x - x0) / sigma;
  y := y_min + (y_max - y_min) * exp(-0.5 * x_adj ^ 2.0);
end act_slow.ftau;</code></pre><table><tr><th style="text-align: right">name</th><th style="text-align: right">unit</th><th style="text-align: right">value</th><th style="text-align: right">label</th></tr><tr><td style="text-align: right">l2.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing from pin p to pin n</td></tr><tr><td style="text-align: right">l2.v</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right"></td><td style="text-align: right">Voltage drop of the two pins (= p.v - n.v)</td></tr><tr><td style="text-align: right">kr.act_total</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">total activation due to slow and fast activation terms</td></tr><tr><td style="text-align: right">kr.inact.tau</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right"></td><td style="text-align: right">time constant for obtaining steady state (i.e. time until difference between n and steady has reduced by a factor of 1/e)</td></tr><tr><td style="text-align: right">kr.inact.steady</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">value that n would reach if v_gate was held constant</td></tr><tr><td style="text-align: right">kr.inact.n</td><td style="text-align: right"></td><td style="text-align: right">0.2938512182797032</td><td style="text-align: right">ratio of molecules in open conformation</td></tr><tr><td style="text-align: right">kr.act_slow.tau</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right"></td><td style="text-align: right">time constant for obtaining steady state (i.e. time until difference between n and steady has reduced by a factor of 1/e)</td></tr><tr><td style="text-align: right">kr.act_slow.steady</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">value that n would reach if v_gate was held constant</td></tr><tr><td style="text-align: right">kr.act_slow.n</td><td style="text-align: right"></td><td style="text-align: right">0.7689430941621821</td><td style="text-align: right">ratio of molecules in open conformation</td></tr><tr><td style="text-align: right">kr.act_fast.tau</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right"></td><td style="text-align: right">time constant for obtaining steady state (i.e. time until difference between n and steady has reduced by a factor of 1/e)</td></tr><tr><td style="text-align: right">kr.act_fast.steady</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">value that n would reach if v_gate was held constant</td></tr><tr><td style="text-align: right">kr.act_fast.n</td><td style="text-align: right"></td><td style="text-align: right">0.7689430941621821</td><td style="text-align: right">ratio of molecules in open conformation</td></tr><tr><td style="text-align: right">kr.g</td><td style="text-align: right">&quot;S&quot;</td><td style="text-align: right"></td><td style="text-align: right">ion conductance</td></tr><tr><td style="text-align: right">kr.i_open</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">i if open_ratio = 1</td></tr><tr><td style="text-align: right">kr.open_ratio</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right"></td><td style="text-align: right">ratio between 0 (fully closed) and 1 (fully open)</td></tr><tr><td style="text-align: right">kr.i_ion</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">current used for ion flux</td></tr><tr><td style="text-align: right">vc.after_pulse</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">true after pulse has passed</td></tr><tr><td style="text-align: right">vc.within_pulse</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">true during pulse</td></tr><tr><td style="text-align: right">vc.vp_last</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">voltage of last pulse</td></tr><tr><td style="text-align: right">vc.tp_last</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">time stamp of start of last pulse</td></tr><tr><td style="text-align: right">vc.peak_indicator</td><td style="text-align: right"></td><td style="text-align: right">false</td><td style="text-align: right">forces event at peak (factor of 1e12 is required to detect zero crossing)</td></tr><tr><td style="text-align: right">vc.tail_i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">peak current after pulse</td></tr><tr><td style="text-align: right">vc.peak_i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">peak current during pulse</td></tr><tr><td style="text-align: right">vc.vs_tail</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_tail</td></tr><tr><td style="text-align: right">vc.vs_end</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_end</td></tr><tr><td style="text-align: right">vc.vs_peak</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_peak</td></tr><tr><td style="text-align: right">vc.is_end</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of current at end of last pulse</td></tr><tr><td style="text-align: right">vc.is_tail</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of peak tail current after last pulse</td></tr><tr><td style="text-align: right">vc.is_peak</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of peak current during last pulse</td></tr><tr><td style="text-align: right">vc.v_pulse</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right"></td><td style="text-align: right">voltage during pulse (must be defined externally)</td></tr><tr><td style="text-align: right">vc.pulse_signal</td><td style="text-align: right"></td><td style="text-align: right">0</td><td style="text-align: right">0 during holding period, 1 during pulse</td></tr><tr><td style="text-align: right">vc.pulse_end</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">signals end of pulse</td></tr><tr><td style="text-align: right">vc.pulse_start</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">signals start of pulse</td></tr><tr><td style="text-align: right">vc.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">measured membrane current</td></tr><tr><td style="text-align: right">vc.g.p.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing into the pin</td></tr><tr><td style="text-align: right">vc.n.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing into the pin</td></tr><tr><td style="text-align: right">$whenCondition1</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.pulse_end</td></tr><tr><td style="text-align: right">$whenCondition2</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.pulse_start</td></tr><tr><td style="text-align: right">$whenCondition3</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.peak_indicator &lt;&gt; pre(vc.peak_indicator) and vc.after_pulse or vc.pulse_end</td></tr><tr><td style="text-align: right">$whenCondition4</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.peak_indicator &lt;&gt; pre(vc.peak_indicator) and vc.within_pulse or vc.pulse_end</td></tr><tr><td style="text-align: right">vc.g.p.v</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">Potential at the pin</td></tr><tr><td style="text-align: right">vc.d_hold</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">5.0</td><td style="text-align: right">holding period</td></tr><tr><td style="text-align: right">vc.d_pulse</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">0.5</td><td style="text-align: right">pulse period</td></tr><tr><td style="text-align: right">vc.v_hold</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.04</td><td style="text-align: right">voltage during holding period</td></tr><tr><td style="text-align: right">v_start</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.04</td><td style="text-align: right">start value for pulse amplitude</td></tr><tr><td style="text-align: right">v_inc</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.005</td><td style="text-align: right">increment for pulse amplitude</td></tr><tr><td style="text-align: right">k_in</td><td style="text-align: right">&quot;mol/m3&quot;</td><td style="text-align: right">140.0</td><td style="text-align: right">intracellular potassium concentration</td></tr><tr><td style="text-align: right">k_ex</td><td style="text-align: right">&quot;mol/m3&quot;</td><td style="text-align: right">5.4</td><td style="text-align: right">extracellular potassium concentration</td></tr><tr><td style="text-align: right">temp</td><td style="text-align: right">&quot;K&quot;</td><td style="text-align: right">288.15</td><td style="text-align: right">cell medium temperature</td></tr><tr><td style="text-align: right">v_k</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">InaMo.Functions.Biochemical.nernst(k_in, k_ex, 1, temp)</td><td style="text-align: right">equilibrium potential for K+ ions</td></tr><tr><td style="text-align: right">kr.v_eq</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">v_k</td><td style="text-align: right">equilibrium potential</td></tr><tr><td style="text-align: right">kr.g_max</td><td style="text-align: right">&quot;S&quot;</td><td style="text-align: right">1.5e-09</td><td style="text-align: right">maximum conductance</td></tr><tr><td style="text-align: right">kr.current_name</td><td style="text-align: right"></td><td style="text-align: right">&quot;I_K,r&quot;</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">l2.c</td><td style="text-align: right">&quot;F&quot;</td><td style="text-align: right">4e-11</td><td style="text-align: right">membrane capacitance</td></tr><tr><td style="text-align: right">l2.v_init</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.09</td><td style="text-align: right">initial potential (from short initial stimulation)</td></tr><tr><td style="text-align: right">l2.use_init</td><td style="text-align: right"></td><td style="text-align: right">false</td><td style="text-align: right">determines whether initial value for v is used</td></tr></table>
      <p>To reproduce Figure S3A and S3B from Inada 2009, plot act_steady and
      act_tau_fast against v.</p>
      <p>Simulation protocol and parameters are chosen with the following
      rationale:</p>
      <ul>
        <li>StopTime: allow a plot from -120 mV to 80 mV</li>
        <li>Tolerance: left at default value, since derivatives are not
        relevant</li>
      </ul>
    <pre><code class="language-modelica">model RapidDelayedRectifierSteady &quot;steady state of I_K,r, recreates figure S3A and S3B from Inada 2009&quot;
  extends Modelica.Icons.Example;
  InaMo.Membrane.LipidBilayer l2(use_init = false) &quot;cell membrane&quot; annotation(
    Placement(transformation(extent = {{17, -17}, {51, 17}})));
  InaMo.ExperimentalMethods.VoltageClamp.VoltageClamp vc &quot;voltage clamp&quot; annotation(
    Placement(transformation(extent = {{-17, -17}, {17, 17}})));
  parameter SI.Concentration k_in = 140 &quot;intracellular potassium concentration&quot;;
  parameter SI.Concentration k_ex = 5.4 &quot;extracellular potassium concentration&quot;;
  parameter SI.Temperature temp = 310 &quot;cell medium temperature&quot;;
  parameter SI.Voltage v_k = nernst(k_in, k_ex, 1, temp) &quot;equilibrium potential for K+ ions&quot;;
  InaMo.Currents.Atrioventricular.RapidDelayedRectifierChannel kr(g_max = 1.5e-9, v_eq = v_k) &quot;I_K,r with parameters of AN cell model&quot; annotation(
    Placement(transformation(extent = {{-51, -17}, {-17, 17}})));
  Real act_steady = kr.act_fast.steady &quot;steady state of activation gates&quot;;
  SI.Duration act_tau_fast = kr.act_fast.tau &quot;time constant of fast activation gate&quot;;
  SI.Duration act_tau_slow = kr.act_slow.tau &quot;time constant of slow activation gate&quot;;
  Real inact_steady = kr.inact.steady &quot;steady state of inactivation gate&quot;;
  SI.Duration inact_tau = kr.inact.tau &quot;time constant of inactivation gate&quot;;
  SI.Voltage v(start = -0.12, fixed = true) &quot;input voltage&quot;;
equation
  vc.v_stim = v;
  der(v) = 0.001;
  connect(l2.p, vc.p) annotation(
    Line(points = {{34, 18}, {34, 18}, {34, 40}, {0, 40}, {0, 18}, {0, 18}}, color = {0, 0, 255}));
  connect(vc.p, kr.p) annotation(
    Line(points = {{0, 18}, {0, 18}, {0, 40}, {-34, 40}, {-34, 18}, {-34, 18}}, color = {0, 0, 255}));
  connect(l2.n, vc.n) annotation(
    Line(points = {{34, -16}, {34, -16}, {34, -40}, {0, -40}, {0, -16}, {0, -16}}, color = {0, 0, 255}));
  connect(vc.n, kr.n) annotation(
    Line(points = {{0, -16}, {0, -16}, {0, -40}, {-34, -40}, {-34, -16}, {-34, -16}}, color = {0, 0, 255}));
  annotation(
    experiment(StartTime = 0, StopTime = 200, Tolerance = 1e-6, Interval = 1),
    __OpenModelica_simulationFlags(lv = &quot;LOG_STATS&quot;, s = &quot;dassl&quot;),
    __MoST_experiment(variableFilter = &quot;act_steady|act_tau_fast|v|act_tau_slow|inact_tau|inact_steady|vc.v&quot;),
    Documentation(info = &quot;
    &lt;html&gt;
      &lt;p&gt;To reproduce Figure S3A and S3B from Inada 2009, plot act_steady and
      act_tau_fast against v.&lt;/p&gt;
      &lt;p&gt;Simulation protocol and parameters are chosen with the following
      rationale:&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;StopTime: allow a plot from -120 mV to 80 mV&lt;/li&gt;
        &lt;li&gt;Tolerance: left at default value, since derivatives are not
        relevant&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/html&gt;
  &quot;));
end RapidDelayedRectifierSteady;</code></pre><h2 id="Tests-for-I_{NaCa}"><a class="docs-heading-anchor" href="#Tests-for-I_{NaCa}">Tests for <span>$I_{NaCa}$</span></a><a id="Tests-for-I_{NaCa}-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-for-I_{NaCa}" title="Permalink"></a></h2>
      <p>This example does not represent the settings of a specific Figure from
      a reference but instead serves as the basis for other models that
      use different variable settings for their experiment setup.</p>
      <p>This example uses a linear input current, because I_NaCa is modeled
      as an immediate current without activation or inactivation kinetics.</p>
      <p>Simulation protocol and parameters are chosen with the following
      rationale:</p>
      <ul>
        <li>StopTime: allow a plot from -140 to +140 mV</li>
        <li>Tolerance: left at default value because derivatives are not
        relevant</li>
        <li>Interval: enough for a smooth plot</li>
      </ul>
    <pre><code class="language-modelica">model SodiumCalciumExchangerLin &quot;IV relationship of I_NaCa, base model for recreation of Figures from Matsuoka 1992, Kurata 2002 and Inada 2009&quot;
  extends Modelica.Icons.Example;
  extends InaMo.Concentrations.Interfaces.CaConst;
  InaMo.Currents.Atrioventricular.SodiumCalciumExchanger naca(k_NaCa = 1e-9) &quot;I_NaCa&quot; annotation(
    Placement(transformation(extent = {{-51, -17}, {-17, 17}})));
  inner parameter SI.Temperature temp = 310 &quot;cell medium temperature&quot;;
  InaMo.Membrane.LipidBilayer l2(c = 40e-12, use_init = false) &quot;cell membrane&quot; annotation(
    Placement(transformation(extent = {{17, -17}, {51, 17}})));
  InaMo.ExperimentalMethods.VoltageClamp.VoltageClamp vc &quot;voltage clamp&quot; annotation(
    Placement(transformation(extent = {{-17, -17}, {17, 17}})));
  inner parameter SI.Concentration na_in = 8 &quot;intracellular sodium concentration&quot;;
  inner parameter SI.Concentration na_ex = 140 &quot;extracellular sodium concentration&quot;;
  inner parameter SI.Concentration ca_ex = 2 &quot;extracellular calcium concentration&quot;;
  InaMo.Concentrations.Basic.ConstantConcentration ca_sub(c_const = 0.1e-3, vol = v_sub) &quot;Ca2+ in \&quot;fuzzy\&quot; subspace&quot; annotation(
    Placement(transformation(extent = {{-51, -80}, {-17, -46}})));
  parameter SI.Voltage v_start = -140e-3 &quot;starting voltage&quot;;
initial equation
  vc.v_stim = v_start;
equation
  der(vc.v_stim) = 0.001;
  connect(l2.p, vc.p) annotation(
    Line(points = {{34, 18}, {34, 18}, {34, 40}, {0, 40}, {0, 18}, {0, 18}}, color = {0, 0, 255}));
  connect(vc.p, naca.p) annotation(
    Line(points = {{0, 18}, {0, 18}, {0, 40}, {-34, 40}, {-34, 18}, {-34, 18}}, color = {0, 0, 255}));
  connect(l2.n, vc.n) annotation(
    Line(points = {{34, -16}, {34, -16}, {34, -40}, {0, -40}, {0, -16}, {0, -16}}, color = {0, 0, 255}));
  connect(vc.n, naca.n) annotation(
    Line(points = {{0, -16}, {0, -16}, {0, -40}, {-34, -40}, {-34, -16}, {-34, -16}}, color = {0, 0, 255}));
  connect(ca_sub.substance, naca.ca) annotation(
    Line(points = {{-34, -80}, {-14, -80}, {-14, -30}, {-28, -30}, {-28, -16}, {-28, -16}}));
  annotation(
    experiment(StartTime = 0, StopTime = 280, Tolerance = 1e-6, Interval = 1),
    __OpenModelica_simulationFlags(lv = &quot;LOG_STATS&quot;, s = &quot;dassl&quot;),
    Documentation(info = &quot;
    &lt;html&gt;
      &lt;p&gt;This example does not represent the settings of a specific Figure from
      a reference but instead serves as the basis for other models that
      use different variable settings for their experiment setup.&lt;/p&gt;
      &lt;p&gt;This example uses a linear input current, because I_NaCa is modeled
      as an immediate current without activation or inactivation kinetics.&lt;/p&gt;
      &lt;p&gt;Simulation protocol and parameters are chosen with the following
      rationale:&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;StopTime: allow a plot from -140 to +140 mV&lt;/li&gt;
        &lt;li&gt;Tolerance: left at default value because derivatives are not
        relevant&lt;/li&gt;
        &lt;li&gt;Interval: enough for a smooth plot&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/html&gt;
  &quot;));
end SodiumCalciumExchangerLin;</code></pre><h2 id="Tests-for-I_{Na}"><a class="docs-heading-anchor" href="#Tests-for-I_{Na}">Tests for <span>$I_{Na}$</span></a><a id="Tests-for-I_{Na}-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-for-I_{Na}" title="Permalink"></a></h2>
      <p>To reproduce Figure 2B from Lindblad 1996, plot cd against
      vc.vs_peak.
      It is necessary to use vc.vs_peak instead of vc.v_pulse, because cd
      captures the current density from the <i>previous</i> pulse.</p>
      <p>Note that results will not be exact as Lindblad 1996 used the full
      model to generate the plots.</p>
      <p>Simulation parameters are chosen with the following
      rationale:</p>
      <ul>
        <li>StopTime: allow a plot from -100 mV to 70 mV</li>
        <p>Tolerance: default value</p
        <li>Interval: roughly show time course of current (Noble 1962 remarks
        that 0.1 ms is the smallest step size needed for RK4.)</li>
      </ul>
      <p>Other parameter settings can be found in Lindblad 1996 on the
      following pages:</p>
      <ul>
        <li>na_in: H1673 (Table 15, initial value)</li>
        <li>na_ex: H1674 (Fig. 2)</li>
        <li>na_p: H1672 (Table 14) + H1673 (top right) + Inada 2009 Supporting material, 27</li>
        <li>temp: H1674 (Fig 2.)</li>
        <li>l2.C: H1672 (Table 14)</li>
        <li>vc.v_hold: H1674 (Fig. 2)</li>
        <li>vc.d_hold: H1674 (Fig. 2) -> Wendt 1992, C1235 (bottom left)</li>
        <li>vc.d_pulse: H1674 (Fig. 2) -> Wendt 1992, C1235 (bottom left)</li>
      </ul>
      <p>NOTE: na_p is the only parameter whose value is not directly taken
      from Lindblad 1996. Lindblad et al. use 1.4 nl while Inada et al. use
      1.4 pl which gives currents in the order of nA instead of μa and
      therefore seems more reasonable (and is more in accordance with the
      plots of Lindblad et al.).</p>
    <pre><code class="language-modelica">model SodiumChannelIV &quot;IV relationship of I_Na, recreates Figure 2 B from Lindblad 1996&quot;
  extends InaMo.Examples.Interfaces.IVBase(vc(v_hold = -0.09, d_hold = 2, d_pulse = 0.05), v_start = -0.1);
  extends Modelica.Icons.Example;
  InaMo.Currents.Atrioventricular.SodiumChannel na &quot;I_Na&quot; annotation(
    Placement(transformation(extent = {{-51, -17}, {-17, 17}})));
  InaMo.Membrane.LipidBilayer l2(use_init = false, c = 50e-12) &quot;cell membrane&quot; annotation(
    Placement(transformation(extent = {{17, -17}, {51, 17}})));
  inner parameter SI.Temperature temp = SI.Conversions.from_degC(35) &quot;cell medium temperature&quot;;
  // Note: uses Lindblad parameters instead of Inada parameters
  // For Inada2009 we would use na_in = 8, na_ex = 140 and na_p = 1.4e-15 at 310K
  // Note: pl/s -&gt; m³/s by setting p *= 1e-15
  inner parameter SI.Concentration na_in = 8.4 &quot;intracellular sodium concentration&quot;;
  inner parameter SI.Concentration na_ex = 75 &quot;extracellular sodium concentration&quot;;
  inner parameter PermeabilityFM na_p = 1.4e-15 * 1.5 &quot;cell membrane permeability for Na+ ions&quot;;
  discrete Real cd(unit = &quot;A/F&quot;) &quot;current density&quot;;
initial equation
  cd = vc.is_peak / l2.c;
equation
  when change(vc.is_peak) then
    cd = vc.is_peak / l2.c;
  end when;
  connect(l2.p, vc.p) annotation(
    Line(points = {{34, 18}, {34, 18}, {34, 40}, {0, 40}, {0, 18}, {0, 18}}, color = {0, 0, 255}));
  connect(vc.p, na.p) annotation(
    Line(points = {{0, 18}, {0, 18}, {0, 40}, {-34, 40}, {-34, 18}, {-34, 18}}, color = {0, 0, 255}));
  connect(l2.n, vc.n) annotation(
    Line(points = {{34, -16}, {34, -16}, {34, -40}, {0, -40}, {0, -16}, {0, -16}}, color = {0, 0, 255}));
  connect(vc.n, na.n) annotation(
    Line(points = {{0, -16}, {0, -16}, {0, -40}, {-34, -40}, {-34, -16}, {-34, -16}}, color = {0, 0, 255}));
  annotation(
    experiment(StartTime = 0, StopTime = 75.8, Tolerance = 1e-6, Interval = 1e-3),
    __OpenModelica_simulationFlags(lv = &quot;LOG_STATS&quot;, s = &quot;dassl&quot;),
    __MoST_experiment(variableFilter = &quot;vc\\.(vs_peak|v|v_pulse)|cd&quot;),
    Documentation(info = &quot;
    &lt;html&gt;
      &lt;p&gt;To reproduce Figure 2B from Lindblad 1996, plot cd against
      vc.vs_peak.
      It is necessary to use vc.vs_peak instead of vc.v_pulse, because cd
      captures the current density from the &lt;i&gt;previous&lt;/i&gt; pulse.&lt;/p&gt;
      &lt;p&gt;Note that results will not be exact as Lindblad 1996 used the full
      model to generate the plots.&lt;/p&gt;
      &lt;p&gt;Simulation parameters are chosen with the following
      rationale:&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;StopTime: allow a plot from -100 mV to 70 mV&lt;/li&gt;
        &lt;p&gt;Tolerance: default value&lt;/p
        &lt;li&gt;Interval: roughly show time course of current (Noble 1962 remarks
        that 0.1 ms is the smallest step size needed for RK4.)&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;Other parameter settings can be found in Lindblad 1996 on the
      following pages:&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;na_in: H1673 (Table 15, initial value)&lt;/li&gt;
        &lt;li&gt;na_ex: H1674 (Fig. 2)&lt;/li&gt;
        &lt;li&gt;na_p: H1672 (Table 14) + H1673 (top right) + Inada 2009 Supporting material, 27&lt;/li&gt;
        &lt;li&gt;temp: H1674 (Fig 2.)&lt;/li&gt;
        &lt;li&gt;l2.C: H1672 (Table 14)&lt;/li&gt;
        &lt;li&gt;vc.v_hold: H1674 (Fig. 2)&lt;/li&gt;
        &lt;li&gt;vc.d_hold: H1674 (Fig. 2) -&gt; Wendt 1992, C1235 (bottom left)&lt;/li&gt;
        &lt;li&gt;vc.d_pulse: H1674 (Fig. 2) -&gt; Wendt 1992, C1235 (bottom left)&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;NOTE: na_p is the only parameter whose value is not directly taken
      from Lindblad 1996. Lindblad et al. use 1.4 nl while Inada et al. use
      1.4 pl which gives currents in the order of nA instead of μa and
      therefore seems more reasonable (and is more in accordance with the
      plots of Lindblad et al.).&lt;/p&gt;
    &lt;/html&gt;
  &quot;));
end SodiumChannelIV;</code></pre><ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mrow><mi> l2.i 
</mi></mrow><mo>+</mo><mrow><mo>(</mo><mrow><mi> na.i_ion 
</mi></mrow><mo>&#8722;</mo><mrow><mi> vc.i 
</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8801;</mo><mn> 0.0 
</mn></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mrow><mi> vc.n.i 
</mi></mrow><mo>+</mo><mrow><mo>(</mo><mrow><mo>&#8722;</mo><mrow><mi> na.i_ion 
</mi></mrow></mrow><mo>&#8722;</mo><mrow><mi> l2.i 
</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8801;</mo><mn> 0.0 
</mn></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> na.i_open 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>ghkFlux</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mrow><mi> temp 
</mi></mrow><mo>,</mo><mrow><mi> na_in 
</mi></mrow><mo>,</mo><mrow><mi> na.ion_ex 
</mi></mrow><mo>,</mo><mrow><mi> na.ion_p 
</mi></mrow><mo>,</mo><mrow><mi> na.ion_z 
</mi></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi> l2.v 
</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mi> l2.i 
</mi></mrow><mo>/</mo><mrow><mi> l2.c 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> vc.within_pulse 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mi> time 
</mi></mrow><mo>&#8722;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.tp_last 
</mi></mrow><mo>)</mo></mrow></mrow></mrow><mo>&lt;</mo><mrow><mi> vc.d_pulse 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> vc.after_pulse 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mi> time 
</mi></mrow><mo>&#8722;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.tp_last 
</mi></mrow><mo>)</mo></mrow></mrow></mrow><mo>&gt;</mo><mrow><mi> vc.d_pulse 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition1 
</mi></mrow><mo>&#8801;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition2 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi> vc.is_peak 
</mi></mrow><mo>&#8800;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.is_peak 
</mi></mrow><mo>)</mo></mrow></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition3 
</mi></mrow><mo>&#8801;</mo><mrow><mi> vc.pulse_start 
</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition4 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>&#8800;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow><mo>&#8743;</mo><mrow><mi> vc.after_pulse 
</mi></mrow><mo>)</mo></mrow><mo>&#8744;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition5 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>&#8800;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow><mo>&#8743;</mo><mrow><mi> vc.within_pulse 
</mi></mrow><mo>)</mo></mrow><mo>&#8744;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow></mrow>
</math>
<li>Within group na (prefix _ indicates shortened variable name)
<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi>_inact_fast.n</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mi>_inact_fast.steady</mi></mrow><mo>&#8722;</mo><mrow><mi>_inact_fast.n</mi></mrow><mo>)</mo></mrow><mo>/</mo><mrow><mi>_inact_fast.tau</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi>_inact_slow.n</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mi>_inact_slow.steady</mi></mrow><mo>&#8722;</mo><mrow><mi>_inact_slow.n</mi></mrow><mo>)</mo></mrow><mo>/</mo><mrow><mi>_inact_slow.tau</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_open_ratio</mi></mrow><mo>&#8801;</mo><mrow><msup><mrow><mi>_act.n</mi></mrow><mn> 3.0 
</mn></msup><mo>&sdot;</mo><mrow><mi>_inact_total</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_i_ion</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_open_ratio</mi></mrow><mo>&sdot;</mo><mrow><mi>_i_open</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_act.alpha</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>falpha</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> -0.0444 
</mn><mo>,</mo><mn> 5829.58 
</mn><mo>,</mo><mn> -78.90791446382072 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_act.beta</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>act.fbeta</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> -0.0444 
</mn><mo>,</mo><mn> -78.90791446382072 
</mn><mo>,</mo><mn> 18400.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact_fast.steady</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>fsteady</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact_fast.tau</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>fsteady.fbeta</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.00035 
</mn><mo>,</mo><mn> 0.03035 
</mn><mo>,</mo><mn> -0.04 
</mn><mo>,</mo><mn> -166.6666666666667 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact_slow.steady</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>fsteady</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact_slow.tau</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>fsteady.fbeta</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.00295 
</mn><mo>,</mo><mn> 0.12295 
</mn><mo>,</mo><mn> -0.06 
</mn><mo>,</mo><mn> -500.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact_total</mi></mrow><mo>&#8801;</mo><mrow><mrow><mn> 0.635 
</mn><mo>&sdot;</mo><mrow><mi>_inact_fast.n</mi></mrow></mrow><mo>+</mo><mrow><mn> 0.365 
</mn><mo>&sdot;</mo><mrow><mi>_inact_slow.n</mi></mrow></mrow></mrow></mrow>
</math>
<li>Within group act (prefix _ indicates shortened variable name)
<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi>_n</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mrow><mi>_alpha</mi></mrow><mo>&sdot;</mo><mrow><mo>(</mo><mn> 1.0 
</mn><mo>&#8722;</mo><mrow><mi>_n</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8722;</mo><mrow><mrow><mi>_beta</mi></mrow><mo>&sdot;</mo><mrow><mi>_n</mi></mrow></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_steady</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_alpha</mi></mrow><mo>/</mo><mrow><mo>(</mo><mrow><mi>_alpha</mi></mrow><mo>+</mo><mrow><mi>_beta</mi></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_tau</mi></mrow><mo>&#8801;</mo><mrow><mn> 1.0 
</mn><mo>/</mo><mrow><mo>(</mo><mrow><mi>_alpha</mi></mrow><mo>+</mo><mrow><mi>_beta</mi></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
</ol>

</ol>

<li>Within group vc (prefix _ indicates shortened variable name)
<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mrow><mi>_g.p.i</mi></mrow><mo>+</mo><mrow><mo>(</mo><mrow><mi>_i</mi></mrow><mo>&#8722;</mo><mrow><mi>_n.i</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8801;</mo><mn> 0.0 
</mn></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> l2.v 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mo>&#8475;</mo><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi>_pulse_signal</mi></mrow><mo>)</mo></mrow></mrow><mo>&sdot;</mo><mrow><mo>(</mo><mrow><mi>_v_pulse</mi></mrow><mo>&#8722;</mo><mrow><mi>_v_hold</mi></mrow><mo>)</mo></mrow></mrow><mo>+</mo><mrow><mi>_v_hold</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_pulse_start</mi></mrow><mo>&#8801;</mo><mrow><sample/><mo>&#8289;</mo><mrow><mo>(</mo><mn> 1 
</mn><mo>,</mo><mrow><mi>_d_hold</mi></mrow><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_pulse_end</mi></mrow><mo>&#8801;</mo><mrow><sample/><mo>&#8289;</mo><mrow><mo>(</mo><mn> 2 
</mn><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_peak_indicator</mi></mrow><mo>&#8801;</mo><mrow><mrow><msup><mrow><mrow><mi>_i</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#215;</mo><mn> 1000000000000.0 
</mn></mrow><mo>&lt;</mo><mn> 0.0 
</mn></mrow></mrow>
</math>
</ol>

</ol>
<p>Functions:</p><pre><code class="language-modelica">function falpha
  input Real x &quot;input value&quot;;
  input Real x0 = -0.0444 &quot;offset for x (fitting parameter)&quot;;
  input Real sy = 5829.58 &quot;scaling factor for y (fitting parameter)&quot;;
  input Real sx = -78.90791446382072 &quot;scaling factor for x (fitting parameter)&quot;;
  output Real y &quot;result&quot;;
  protected Real x_adj &quot;adjusted x with offset and scaling factor&quot;;
algorithm
  x_adj := sx * (x - x0);
  if abs(x - x0) &lt; 1e-06 then
    y := sy;
  else
    y := sy * x_adj / (exp(x_adj) - 1.0);
  end if;
end falpha;</code></pre><pre><code class="language-modelica">function fsteady.fbeta
  input Real x &quot;input value&quot;;
  input Real y_min = 0.0 &quot;lower asymptote (fitting parameter)&quot;;
  input Real y_max = 1491.0 &quot;upper asmyptote when d_off=1 and nu=1 (fititng parameter)&quot;;
  input Real x0 = -0.0946 &quot;x-value of sigmoid midpoint when d_off=1 and nu=1 (fitting parameter)&quot;;
  input Real sx = 77.51937984496124 &quot;scaling factor for x axis (i.e. steepness, fitting parameter)&quot;;
  input Real se = 323.3 &quot;scaling factor for exponential part (fitting parameter)&quot;;
  input Real d_off = 1.0 &quot;offset in denominator (affects upper asymptote, fitting parameter)&quot;;
  input Real nu = 1.0 &quot;reciprocal of exponent of denominator (affects upper asymptote, fitting parameter)&quot;;
  output Real y &quot;result&quot;;
  protected Real x_adj &quot;adjusted x with offset and scaling factor&quot;;
algorithm
  x_adj := sx * (x - x0);
  y := y_min + (y_max - y_min) / (se * exp(-x_adj) + d_off) ^ (1.0 / nu);
end fsteady.fbeta;</code></pre><pre><code class="language-modelica">function nernst &quot;Nernst equation to find the equlibrium potential for a single ion&quot;
  input Real ion_in(quantity = &quot;Concentration&quot;, unit = &quot;mol/m3&quot;) &quot;intracellular ion concentration&quot;;
  input Real ion_ex(quantity = &quot;Concentration&quot;, unit = &quot;mol/m3&quot;) &quot;extracellular ion concentration&quot;;
  input Integer ion_z &quot;valence of ion&quot;;
  input Real temp(quantity = &quot;ThermodynamicTemperature&quot;, unit = &quot;K&quot;, displayUnit = &quot;degC&quot;, min = 0.0, start = 288.15, nominal = 300.0) &quot;cell medium temperature&quot;;
  output Real v_eq(quantity = &quot;ElectricPotential&quot;, unit = &quot;V&quot;) &quot;equlibirium potential&quot;;
algorithm
  v_eq := 8.3144598 * temp / /*Real*/(ion_z) / 96485.33289000001 * log(ion_ex / ion_in);
end nernst;</code></pre><pre><code class="language-modelica">function fsteady
  input Real x &quot;input value&quot;;
  output Real y &quot;result of applying the HH-style equation steady = alpha/(alpha + beta)&quot;;
algorithm
  y := act.fbeta(x, -0.0669, -1000.0 / 5.57, 44.9) / (act.fbeta(x, -0.0669, -1000.0 / 5.57, 44.9) + fsteady.fbeta(x, 0.0, 1491.0, -0.0946, 1000.0 / 12.9, 323.3, 1.0, 1.0));
end fsteady;</code></pre><pre><code class="language-modelica">function absmax &quot;returns input whose absolute value is larger, preserving the sign&quot;
  input Real a &quot;first input&quot;;
  input Real b &quot;second input&quot;;
  output Real m &quot;a if abs(a) &gt; abs(b), otherwise b&quot;;
algorithm
  m := if abs(a) &gt; abs(b) then a else b;
end absmax;</code></pre><pre><code class="language-modelica">function ghkFlux &quot;ghk flux equation for a single ion&quot;
  input Real v(quantity = &quot;ElectricPotential&quot;, unit = &quot;V&quot;) &quot;membrane potential&quot;;
  input Real temp(quantity = &quot;ThermodynamicTemperature&quot;, unit = &quot;K&quot;, displayUnit = &quot;degC&quot;, min = 0.0, start = 288.15, nominal = 300.0) &quot;cell medium temperature&quot;;
  input Real ion_in(quantity = &quot;Concentration&quot;, unit = &quot;mol/m3&quot;) &quot;intracellular ion concentration&quot;;
  input Real ion_ex(quantity = &quot;Concentration&quot;, unit = &quot;mol/m3&quot;) &quot;extracellular ion concentration&quot;;
  input Real ion_p(quantity = &quot;Permeability (fluid mechanics)&quot;, unit = &quot;m3/(s.m2)&quot;) &quot;permeability of cell membrane to Na+ cations&quot;;
  input Integer ion_z &quot;ion valence&quot;;
  output Real i(quantity = &quot;CurrentDensity&quot;, unit = &quot;A/m2&quot;) &quot;current density resulting from ion flux through membrane&quot;;
  protected Real g_max(quantity = &quot;Conductance&quot;, unit = &quot;S&quot;);
  protected Real v_eq(quantity = &quot;ElectricPotential&quot;, unit = &quot;V&quot;);
  protected Real FoRT(unit = &quot;1/V&quot;) = 96485.33289000001 / (8.3144598 * temp);
algorithm
  g_max := ion_p * ion_ex * FoRT * 96485.33289000001 * /*Real*/(ion_z) ^ 2.0;
  v_eq := nernst(ion_in, ion_ex, ion_z, temp);
  if abs(v) &lt; 1e-06 then
    i := g_max / FoRT / /*Real*/(ion_z) * (exp(-v_eq * FoRT * /*Real*/(ion_z)) - 1.0);
  else
    i := g_max * v * (exp((v - v_eq) * FoRT * /*Real*/(ion_z)) - 1.0) / (exp(v * FoRT * /*Real*/(ion_z)) - 1.0);
  end if;
end ghkFlux;</code></pre><pre><code class="language-modelica">function act.fbeta
  input Real x &quot;input value&quot;;
  input Real x0 = -0.0444 &quot;x-value where y = 1 (fitting parameter)&quot;;
  input Real sx = -78.90791446382072 &quot;scaling factor for x axis (fitting parameter)&quot;;
  input Real sy = 18400.0 &quot;scaling factor for y axis (fitting parameter)&quot;;
  output Real y &quot;result&quot;;
algorithm
  y := sy * exp(sx * (x - x0));
end act.fbeta;</code></pre><table><tr><th style="text-align: right">name</th><th style="text-align: right">unit</th><th style="text-align: right">value</th><th style="text-align: right">label</th></tr><tr><td style="text-align: right">cd</td><td style="text-align: right">&quot;A/F&quot;</td><td style="text-align: right"></td><td style="text-align: right">current density</td></tr><tr><td style="text-align: right">l2.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing from pin p to pin n</td></tr><tr><td style="text-align: right">l2.v</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right"></td><td style="text-align: right">Voltage drop of the two pins (= p.v - n.v)</td></tr><tr><td style="text-align: right">na.inact_total</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">total inactivation resulting from fast and slow inactivation terms</td></tr><tr><td style="text-align: right">na.inact_slow.tau</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right"></td><td style="text-align: right">time constant for obtaining steady state (i.e. time until difference between n and steady has reduced by a factor of 1/e)</td></tr><tr><td style="text-align: right">na.inact_slow.steady</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">value that n would reach if v_gate was held constant</td></tr><tr><td style="text-align: right">na.inact_slow.n</td><td style="text-align: right"></td><td style="text-align: right">2.217110758230417e-07</td><td style="text-align: right">ratio of molecules in open conformation</td></tr><tr><td style="text-align: right">na.inact_fast.tau</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right"></td><td style="text-align: right">time constant for obtaining steady state (i.e. time until difference between n and steady has reduced by a factor of 1/e)</td></tr><tr><td style="text-align: right">na.inact_fast.steady</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">value that n would reach if v_gate was held constant</td></tr><tr><td style="text-align: right">na.inact_fast.n</td><td style="text-align: right"></td><td style="text-align: right">2.217110758230417e-07</td><td style="text-align: right">ratio of molecules in open conformation</td></tr><tr><td style="text-align: right">na.act.tau</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right"></td><td style="text-align: right">time constant for obtaining steady state (i.e. time until difference between n and steady has reduced by a factor of 1/e)</td></tr><tr><td style="text-align: right">na.act.steady</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right"></td><td style="text-align: right">steady state achieved if current voltage is held constant</td></tr><tr><td style="text-align: right">na.act.beta</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right"></td><td style="text-align: right">rate of transfer from open to closed conformation</td></tr><tr><td style="text-align: right">na.act.alpha</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right"></td><td style="text-align: right">rate of transfer from closed to open conformation</td></tr><tr><td style="text-align: right">na.act.n</td><td style="text-align: right"></td><td style="text-align: right">0.9743799231069017</td><td style="text-align: right">ratio of molecules in open conformation</td></tr><tr><td style="text-align: right">na.i_open</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">i if open_ratio = 1</td></tr><tr><td style="text-align: right">na.open_ratio</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">ratio between 0 (fully closed) and 1 (fully open)</td></tr><tr><td style="text-align: right">na.i_ion</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">current used for ion flux</td></tr><tr><td style="text-align: right">vc.after_pulse</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">true after pulse has passed</td></tr><tr><td style="text-align: right">vc.within_pulse</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">true during pulse</td></tr><tr><td style="text-align: right">vc.vp_last</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">voltage of last pulse</td></tr><tr><td style="text-align: right">vc.tp_last</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">time stamp of start of last pulse</td></tr><tr><td style="text-align: right">vc.peak_indicator</td><td style="text-align: right"></td><td style="text-align: right">false</td><td style="text-align: right">forces event at peak (factor of 1e12 is required to detect zero crossing)</td></tr><tr><td style="text-align: right">vc.tail_i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">peak current after pulse</td></tr><tr><td style="text-align: right">vc.peak_i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">peak current during pulse</td></tr><tr><td style="text-align: right">vc.vs_tail</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_tail</td></tr><tr><td style="text-align: right">vc.vs_end</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_end</td></tr><tr><td style="text-align: right">vc.vs_peak</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_peak</td></tr><tr><td style="text-align: right">vc.is_end</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of current at end of last pulse</td></tr><tr><td style="text-align: right">vc.is_tail</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of peak tail current after last pulse</td></tr><tr><td style="text-align: right">vc.is_peak</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of peak current during last pulse</td></tr><tr><td style="text-align: right">vc.v_pulse</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right"></td><td style="text-align: right">voltage during pulse (must be defined externally)</td></tr><tr><td style="text-align: right">vc.pulse_signal</td><td style="text-align: right"></td><td style="text-align: right">0</td><td style="text-align: right">0 during holding period, 1 during pulse</td></tr><tr><td style="text-align: right">vc.pulse_end</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">signals end of pulse</td></tr><tr><td style="text-align: right">vc.pulse_start</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">signals start of pulse</td></tr><tr><td style="text-align: right">vc.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">measured membrane current</td></tr><tr><td style="text-align: right">vc.g.p.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing into the pin</td></tr><tr><td style="text-align: right">vc.n.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing into the pin</td></tr><tr><td style="text-align: right">$whenCondition1</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.pulse_end</td></tr><tr><td style="text-align: right">$whenCondition2</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.is_peak &lt;&gt; pre(vc.is_peak)</td></tr><tr><td style="text-align: right">$whenCondition3</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.pulse_start</td></tr><tr><td style="text-align: right">$whenCondition4</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.peak_indicator &lt;&gt; pre(vc.peak_indicator) and vc.after_pulse or vc.pulse_end</td></tr><tr><td style="text-align: right">$whenCondition5</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.peak_indicator &lt;&gt; pre(vc.peak_indicator) and vc.within_pulse or vc.pulse_end</td></tr><tr><td style="text-align: right">vc.g.p.v</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">Potential at the pin</td></tr><tr><td style="text-align: right">vc.d_hold</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">2.0</td><td style="text-align: right">holding period</td></tr><tr><td style="text-align: right">vc.d_pulse</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">0.05</td><td style="text-align: right">pulse period</td></tr><tr><td style="text-align: right">vc.v_hold</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.09</td><td style="text-align: right">voltage during holding period</td></tr><tr><td style="text-align: right">v_start</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.1</td><td style="text-align: right">start value for pulse amplitude</td></tr><tr><td style="text-align: right">v_inc</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.005</td><td style="text-align: right">increment for pulse amplitude</td></tr><tr><td style="text-align: right">na.ion_ex</td><td style="text-align: right">&quot;mol/m3&quot;</td><td style="text-align: right">na_ex</td><td style="text-align: right">extracellular concentration of ion</td></tr><tr><td style="text-align: right">na.ion_p</td><td style="text-align: right">&quot;m3/(s.m2)&quot;</td><td style="text-align: right">na_p</td><td style="text-align: right">permeability of ion</td></tr><tr><td style="text-align: right">na.ion_z</td><td style="text-align: right"></td><td style="text-align: right">1</td><td style="text-align: right">valence of ion</td></tr><tr><td style="text-align: right">na.current_name</td><td style="text-align: right"></td><td style="text-align: right">&quot;I_Na&quot;</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">l2.c</td><td style="text-align: right">&quot;F&quot;</td><td style="text-align: right">5e-11</td><td style="text-align: right">membrane capacitance</td></tr><tr><td style="text-align: right">l2.v_init</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.09</td><td style="text-align: right">initial potential (from short initial stimulation)</td></tr><tr><td style="text-align: right">l2.use_init</td><td style="text-align: right"></td><td style="text-align: right">false</td><td style="text-align: right">determines whether initial value for v is used</td></tr><tr><td style="text-align: right">temp</td><td style="text-align: right">&quot;K&quot;</td><td style="text-align: right">288.15</td><td style="text-align: right">cell medium temperature</td></tr><tr><td style="text-align: right">na_in</td><td style="text-align: right">&quot;mol/m3&quot;</td><td style="text-align: right">8.4</td><td style="text-align: right">intracellular sodium concentration</td></tr><tr><td style="text-align: right">na_ex</td><td style="text-align: right">&quot;mol/m3&quot;</td><td style="text-align: right">75.0</td><td style="text-align: right">extracellular sodium concentration</td></tr><tr><td style="text-align: right">na_p</td><td style="text-align: right">&quot;m3/(s.m2)&quot;</td><td style="text-align: right">2.1e-15</td><td style="text-align: right">cell membrane permeability for Na+ ions</td></tr><tr><td style="text-align: right">na.ion_in</td><td style="text-align: right">&quot;mol/m3&quot;</td><td style="text-align: right">na_in</td><td style="text-align: right">intracellular concentration of ion</td></tr></table>
      <p>To reproduce Figure 2A from Lindblad 1996, plot m3 against
      (vc.v_stim - v_step) and h_total against vc.v_stim.</p>
      <p>To reproduce Figure 2C-E, plot tau_m, tau_h1, and tau_h2
      respectively against vc.v_stim.</p>
      <p>Results should be fully accurate.</p>
      <p>Simulation protocol and parameters are chosen with the following
      rationale:</p>
      <ul>
        <li>StopTime: allow a plot from -100 mV to 100 mV</li>
        <li>Tolerance: default value</li>
        <li>Interval: enough to get correct peak values, but to follow time
        course of current at least an interval of 1e-4 s is needed</li>
      </ul>
      <p>NOTE: This model could be much simpler if we would only
      calculate the steady states. However, this setup allows to actually
      inspect the time course of the variables to see when they will reach
      their steady state. Since the parameter n of the activation gate has a
      very low time constant (10-65 μs), the default experiment setup will
      only let you see the point in time where the steady state is almost
      reached. If you want more detail, you will have to decrease the
      simulation interval at least to 1e-4 (i.e. 100 μs).</p>
    <pre><code class="language-modelica">model SodiumChannelSteady &quot;steady state of I_Na, recreates Figures 2A, 2C, 2D and 2E from Lindblad 1996&quot;
  extends Modelica.Icons.Example;
  InaMo.Currents.Atrioventricular.SodiumChannel na &quot;I_Na&quot; annotation(
    Placement(transformation(extent = {{-51, -17}, {-17, 17}})));
  InaMo.Membrane.LipidBilayer l2(use_init = false) &quot;cell membrane&quot; annotation(
    Placement(transformation(extent = {{17, -17}, {51, 17}})));
  // Note: uses Lindblad parameters instead of Inada parameters (8, 140, 1.4e-9, 1), 310K
  inner parameter SI.Temperature temp = SI.Conversions.from_degC(35) &quot;cell medium temperature&quot;;
  inner parameter SI.Concentration na_in = 8.4 &quot;intracellular sodium concentration&quot;;
  inner parameter SI.Concentration na_ex = 75 &quot;extracellular sodium concentration&quot;;
  inner parameter PermeabilityFM na_p = 1.4e-9 * 1.5 &quot;cell membrane permeability for Na+ ions&quot;;
  InaMo.ExperimentalMethods.VoltageClamp.VoltageClamp vc(v_stim(start = -0.1, fixed = true)) &quot;voltage clamp&quot; annotation(
    Placement(transformation(extent = {{-17, -17}, {17, 17}})));
  parameter SI.Duration d_step = 2 &quot;duration for which voltage is held constant between steps&quot;;
  parameter SI.Voltage v_step = 0.005 &quot;size of voltage step&quot;;
  discrete Real m3(start = 0, fixed = true) &quot;total activation of channel (m^3)&quot;;
  discrete Real h_total(start = 0, fixed = true) &quot;total inactivation of channel&quot;;
  Real m_steady = na.act.alpha / (na.act.alpha + na.act.beta) &quot;steady state for activation gate&quot;;
  Real m3_steady = m_steady ^ 3 &quot;steady state of total activation&quot;;
  Real h_steady = na.inact_fast.steady &quot;steady state of inactivation gate&quot;;
  SI.Duration tau_m = na.act.tau &quot;time constant of activation gate&quot;;
  SI.Duration tau_m_measured(start = 0, fixed = true) &quot;measured time until difference between na.act.n and m_stead is &lt; 1e-6&quot;;
  SI.Duration tau_h1 = na.inact_fast.tau &quot;time constant of fast inactivation gate&quot;;
  SI.Duration tau_h2 = na.inact_slow.tau &quot;time constant of slow inactivation gate&quot;;
  SI.Time t_tau_m(start = 0, fixed = true) &quot;time stamp of last voltage step&quot;;
  Real v_na = nernst(na_in, na_ex, 1, temp) &quot;equilibrium potential for Na+ ions&quot;;
equation
  connect(l2.p, vc.p) annotation(
    Line(points = {{34, 18}, {34, 18}, {34, 40}, {0, 40}, {0, 18}, {0, 18}}, color = {0, 0, 255}));
  connect(vc.p, na.p) annotation(
    Line(points = {{0, 18}, {0, 18}, {0, 40}, {-34, 40}, {-34, 18}, {-34, 18}}, color = {0, 0, 255}));
  connect(l2.n, vc.n) annotation(
    Line(points = {{34, -16}, {34, -16}, {34, -40}, {0, -40}, {0, -16}, {0, -16}}, color = {0, 0, 255}));
  connect(vc.n, na.n) annotation(
    Line(points = {{0, -16}, {0, -16}, {0, -40}, {-34, -40}, {-34, -16}, {-34, -16}}, color = {0, 0, 255}));
  when abs(m_steady - na.act.n) &lt; 1e-6 then
    tau_m_measured = time - pre(t_tau_m);
  end when &quot;forces event when steady state is almost reached&quot;;
  when sample(0, d_step) then
// reset stimulation voltage
    reinit(vc.v_stim, pre(vc.v_stim) + v_step);
// record values from last cycle
    m3 = pre(na.act.n) ^ 3;
    h_total = pre(na.inact_total);
    t_tau_m = time;
  end when;
  der(vc.v_stim) = 0 &quot;hold v_stim constant&quot;;
  annotation(
    experiment(StartTime = 0, StopTime = 82, Tolerance = 1e-6, Interval = 1e-2),
    __OpenModelica_simulationFlags(lv = &quot;LOG_STATS&quot;, s = &quot;dassl&quot;),
    __MoST_experiment(variableFilter = &quot;m3_steady|h_steady|m3|vc\\.(v_sim|v)|v_step|h_total|tau_(m|h1|h2)&quot;),
    Documentation(info = &quot;
    &lt;html&gt;
      &lt;p&gt;To reproduce Figure 2A from Lindblad 1996, plot m3 against
      (vc.v_stim - v_step) and h_total against vc.v_stim.&lt;/p&gt;
      &lt;p&gt;To reproduce Figure 2C-E, plot tau_m, tau_h1, and tau_h2
      respectively against vc.v_stim.&lt;/p&gt;
      &lt;p&gt;Results should be fully accurate.&lt;/p&gt;
      &lt;p&gt;Simulation protocol and parameters are chosen with the following
      rationale:&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;StopTime: allow a plot from -100 mV to 100 mV&lt;/li&gt;
        &lt;li&gt;Tolerance: default value&lt;/li&gt;
        &lt;li&gt;Interval: enough to get correct peak values, but to follow time
        course of current at least an interval of 1e-4 s is needed&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;NOTE: This model could be much simpler if we would only
      calculate the steady states. However, this setup allows to actually
      inspect the time course of the variables to see when they will reach
      their steady state. Since the parameter n of the activation gate has a
      very low time constant (10-65 μs), the default experiment setup will
      only let you see the point in time where the steady state is almost
      reached. If you want more detail, you will have to decrease the
      simulation interval at least to 1e-4 (i.e. 100 μs).&lt;/p&gt;
    &lt;/html&gt;
  &quot;));
end SodiumChannelSteady;</code></pre><h2 id="Tests-for-I_p"><a class="docs-heading-anchor" href="#Tests-for-I_p">Tests for <span>$I_p$</span></a><a id="Tests-for-I_p-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-for-I_p" title="Permalink"></a></h2>
      <p>To recreate Figure 12 of Demir 1994, plot p.i against vc.v.</p>
      <p>This example uses a linear input current, because I_p is modeled
      as an immediate current without activation or inactivation kinetics.</p>
      <p>The results are not fully accurate, because Demir 1994 only report
      the current-voltage relationship of the <i>sum</i> of I_p and the
      three background currents included in their model.</p>
      <p>Simulation protocol and parameters are chosen with the following
      rationale:</p>
      <ul>
        <li>StopTime: allow a plot from -60 to +40 mV</li>
        <li>Tolerance: left at default, because derivatives are not relevant
        </li>
        <li>Interval: enough for a smooth plot</li>
        <li>l2.C: according to Table A9 from Demir 1994</li>
        <li>sodium.c_in: according to Table A13 from Demir 1994 (mean)</li>
        <li>sodium.c_ex: according to Table A13 from Demir 1994 (mean)</li>
        <li>potassium.c_in: according to Table A13 from Demir 1994 (mean)</li>
        <li>potassium.c_ex: according to Table A13 from Demir 1994 (mean)</li>
        <li>p.i_max: according to Table A9 from Demir 1994</li>
        <li>p.k_m_K: according to Table A9 from Demir 1994</li>
        <li>p.k_m_Na: according to Table A9 from Demir 1994 and
        Table 10 from Zhang 2000 (identical)</li>
      </ul>
      <p>NOTE: Inada et al. give no parameter values for p.k_m_K and p.k_m_Na.
      These parameters have to be taken from Zhang 2000 or Demir 1994.
      Fortunately, both papers agree for the value of p.k_m_K. For p.k_m_Na
      there seems to be a flipped digit since Demir 1994 gives the value 5.46
      and Zhang 2000 gives the value 5.64. Since we want to replicate Demir
      1994 in this example, we chose to use this value.
      For p.i_max, there exists one value in Table A9 from Demir 1994
      and two different values for peripheral and central SA node cells in
      Zhang 2000. We assume that the &quot;peripheral&quot; value should be
      used for AN cells and the &quot;central&quot; value should be used for
      the N cell. As for the NH cell we currently have no good guess. The
      CellML implementation gives values for p.i_max that do not correspond to
      either Zhang 2000 or Demir 1994. It might be that the authors had the
      code of Inada et al. as reference, but we cannot be sure of that.</p>
    <pre><code class="language-modelica">model SodiumPotassiumPumpLin &quot;IV relationship of I_p, recreates Figure 12 of Demir 1994&quot;
  extends Modelica.Icons.Example;
  InaMo.Membrane.LipidBilayer l2(c = 55e-12, use_init = false) &quot;cell membrane&quot; annotation(
    Placement(transformation(extent = {{17, -17}, {51, 17}})));
  InaMo.ExperimentalMethods.VoltageClamp.VoltageClamp vc &quot;voltage clamp&quot; annotation(
    Placement(transformation(extent = {{-17, -17}, {17, 17}})));
  inner parameter SI.Concentration na_in = 9.67 &quot;intracellular sodium concentration&quot;;
  inner parameter SI.Concentration k_ex = 5.4 &quot;extracellular potassium concentration&quot;;
  InaMo.Currents.Atrioventricular.SodiumPotassiumPump p(i_max = 0.2192e-9, k_m_Na = 5.46) &quot;cell membrane permeability for Na+ ions&quot; annotation(
    Placement(transformation(extent = {{-51, -17}, {-17, 17}})));
  parameter SI.Voltage v_start = -0.06 &quot;starting value for voltage&quot;;
initial equation
  vc.v_stim = v_start;
equation
  der(vc.v_stim) = 0.001;
  connect(l2.p, vc.p) annotation(
    Line(points = {{34, 18}, {34, 18}, {34, 40}, {0, 40}, {0, 18}, {0, 18}}, color = {0, 0, 255}));
  connect(vc.p, p.p) annotation(
    Line(points = {{0, 18}, {0, 18}, {0, 40}, {-34, 40}, {-34, 18}, {-34, 18}}, color = {0, 0, 255}));
  connect(l2.n, vc.n) annotation(
    Line(points = {{34, -16}, {34, -16}, {34, -40}, {0, -40}, {0, -16}, {0, -16}}, color = {0, 0, 255}));
  connect(vc.n, p.n) annotation(
    Line(points = {{0, -16}, {0, -16}, {0, -40}, {-34, -40}, {-34, -16}, {-34, -16}}, color = {0, 0, 255}));
  annotation(
    experiment(StartTime = 0, StopTime = 100, Tolerance = 1e-6, Interval = 1),
    __OpenModelica_simulationFlags(lv = &quot;LOG_STATS&quot;, s = &quot;dassl&quot;),
    __MoST_experiment(variableFilter = &quot;p\\.i|vc\\.v&quot;),
    Documentation(info = &quot;
    &lt;html&gt;
      &lt;p&gt;To recreate Figure 12 of Demir 1994, plot p.i against vc.v.&lt;/p&gt;
      &lt;p&gt;This example uses a linear input current, because I_p is modeled
      as an immediate current without activation or inactivation kinetics.&lt;/p&gt;
      &lt;p&gt;The results are not fully accurate, because Demir 1994 only report
      the current-voltage relationship of the &lt;i&gt;sum&lt;/i&gt; of I_p and the
      three background currents included in their model.&lt;/p&gt;
      &lt;p&gt;Simulation protocol and parameters are chosen with the following
      rationale:&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;StopTime: allow a plot from -60 to +40 mV&lt;/li&gt;
        &lt;li&gt;Tolerance: left at default, because derivatives are not relevant
        &lt;/li&gt;
        &lt;li&gt;Interval: enough for a smooth plot&lt;/li&gt;
        &lt;li&gt;l2.C: according to Table A9 from Demir 1994&lt;/li&gt;
        &lt;li&gt;sodium.c_in: according to Table A13 from Demir 1994 (mean)&lt;/li&gt;
        &lt;li&gt;sodium.c_ex: according to Table A13 from Demir 1994 (mean)&lt;/li&gt;
        &lt;li&gt;potassium.c_in: according to Table A13 from Demir 1994 (mean)&lt;/li&gt;
        &lt;li&gt;potassium.c_ex: according to Table A13 from Demir 1994 (mean)&lt;/li&gt;
        &lt;li&gt;p.i_max: according to Table A9 from Demir 1994&lt;/li&gt;
        &lt;li&gt;p.k_m_K: according to Table A9 from Demir 1994&lt;/li&gt;
        &lt;li&gt;p.k_m_Na: according to Table A9 from Demir 1994 and
        Table 10 from Zhang 2000 (identical)&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;NOTE: Inada et al. give no parameter values for p.k_m_K and p.k_m_Na.
      These parameters have to be taken from Zhang 2000 or Demir 1994.
      Fortunately, both papers agree for the value of p.k_m_K. For p.k_m_Na
      there seems to be a flipped digit since Demir 1994 gives the value 5.46
      and Zhang 2000 gives the value 5.64. Since we want to replicate Demir
      1994 in this example, we chose to use this value.
      For p.i_max, there exists one value in Table A9 from Demir 1994
      and two different values for peripheral and central SA node cells in
      Zhang 2000. We assume that the &amp;quot;peripheral&amp;quot; value should be
      used for AN cells and the &amp;quot;central&amp;quot; value should be used for
      the N cell. As for the NH cell we currently have no good guess. The
      CellML implementation gives values for p.i_max that do not correspond to
      either Zhang 2000 or Demir 1994. It might be that the authors had the
      code of Inada et al. as reference, but we cannot be sure of that.&lt;/p&gt;
    &lt;/html&gt;
  &quot;));
end SodiumPotassiumPumpLin;</code></pre><h2 id="Tests-for-I_{st}"><a class="docs-heading-anchor" href="#Tests-for-I_{st}">Tests for <span>$I_{st}$</span></a><a id="Tests-for-I_{st}-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-for-I_{st}" title="Permalink"></a></h2>
    <p>To reproduce Figure S5B from Inada 2009, plot vc.i against time
    starting 50 ms before and ending 100 ms after the pulses with amplitude
    -80 to 60 mV (in 10 mV increments).</p>
    <p>To reproduce Figure S5C from Inada 2009, plot vc.is_peak against
    vc.vs_peak.
    It is necessary to use vc.vs_peak instead of vc.v_pulse,
    because vc.is_peak captures the current from the <i>previous</i> pulse.</p>
    <p>Simulation protocol and parameters are chosen with the following
    rationale:</p>
    <ul>
      <li>StopTime: allow a plot from -80 mV to 60 mV</li>
      <li>Tolerance: default value</li>
      <li>d_pulse: according to description of Figure S5 in Inada 2009</li>
      <li>d_hold: approximately 5 * max(inact.tau)</li>
      <li>v_hold: according to description of Figure S5 in Inada 2009</li>
      <li>l2.C: according to Table S15 in Inada 2009 (N cell model)</li>
      <li>st.g_max: manually adjusted, because it gives better agreement
      with both Figures S5B and S5C (see note below)</li>
    </ul>
    <p>NOTE: The value for g_max had to be adjusted to obtain
    current densities that are comparable to those in Figure S5B and S5C in
    Inada 2009.
    This is probably because Inada et al. fitted the model to experimental
    data without stating this in the figure description.</p>
    <pre><code class="language-modelica">model SustainedInwardIV &quot;IV relationship of I_st, recreates Figure S5B and S5C of Inada 2009&quot;
  extends InaMo.Examples.Interfaces.IVBase(vc(v_hold = -0.08, d_hold = 15, d_pulse = 0.5), v_start = -0.08, v_inc = 0.005);
  extends Modelica.Icons.Example;
  InaMo.Currents.Atrioventricular.SustainedInwardChannel st(g_max = 0.27e-9) &quot;I_st&quot; annotation(
    Placement(transformation(extent = {{-51, -17}, {-17, 17}})));
  InaMo.Membrane.LipidBilayer l2(use_init = false, c = 29e-12) &quot;cell membrane&quot; annotation(
    Placement(transformation(extent = {{17, -17}, {51, 17}})));
equation
  connect(l2.p, vc.p) annotation(
    Line(points = {{34, 18}, {34, 18}, {34, 40}, {0, 40}, {0, 18}, {0, 18}}, color = {0, 0, 255}));
  connect(vc.p, st.p) annotation(
    Line(points = {{0, 18}, {0, 18}, {0, 40}, {-34, 40}, {-34, 18}, {-34, 18}}, color = {0, 0, 255}));
  connect(l2.n, vc.n) annotation(
    Line(points = {{34, -16}, {34, -16}, {34, -40}, {0, -40}, {0, -16}, {0, -16}}, color = {0, 0, 255}));
  connect(vc.n, st.n) annotation(
    Line(points = {{0, -16}, {0, -16}, {0, -40}, {-34, -40}, {-34, -16}, {-34, -16}}, color = {0, 0, 255}));
  annotation(
    experiment(StartTime = 0, StopTime = 480, Tolerance = 1e-6, Interval = 1e-2),
    __OpenModelica_simulationFlags(lv = &quot;LOG_STATS&quot;, s = &quot;dassl&quot;),
    __MoST_experiment(variableFilter = &quot;vc\\.(is_peak|vs_peak|i|v|v_pulse)&quot;),
    Documentation(info = &quot;
    &lt;html&gt;
    &lt;p&gt;To reproduce Figure S5B from Inada 2009, plot vc.i against time
    starting 50 ms before and ending 100 ms after the pulses with amplitude
    -80 to 60 mV (in 10 mV increments).&lt;/p&gt;
    &lt;p&gt;To reproduce Figure S5C from Inada 2009, plot vc.is_peak against
    vc.vs_peak.
    It is necessary to use vc.vs_peak instead of vc.v_pulse,
    because vc.is_peak captures the current from the &lt;i&gt;previous&lt;/i&gt; pulse.&lt;/p&gt;
    &lt;p&gt;Simulation protocol and parameters are chosen with the following
    rationale:&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;StopTime: allow a plot from -80 mV to 60 mV&lt;/li&gt;
      &lt;li&gt;Tolerance: default value&lt;/li&gt;
      &lt;li&gt;d_pulse: according to description of Figure S5 in Inada 2009&lt;/li&gt;
      &lt;li&gt;d_hold: approximately 5 * max(inact.tau)&lt;/li&gt;
      &lt;li&gt;v_hold: according to description of Figure S5 in Inada 2009&lt;/li&gt;
      &lt;li&gt;l2.C: according to Table S15 in Inada 2009 (N cell model)&lt;/li&gt;
      &lt;li&gt;st.g_max: manually adjusted, because it gives better agreement
      with both Figures S5B and S5C (see note below)&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;NOTE: The value for g_max had to be adjusted to obtain
    current densities that are comparable to those in Figure S5B and S5C in
    Inada 2009.
    This is probably because Inada et al. fitted the model to experimental
    data without stating this in the figure description.&lt;/p&gt;
    &lt;/html&gt;
  &quot;));
end SustainedInwardIV;</code></pre><ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mrow><mi> l2.i 
</mi></mrow><mo>+</mo><mrow><mo>(</mo><mrow><mi> st.i_ion 
</mi></mrow><mo>&#8722;</mo><mrow><mi> vc.i 
</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8801;</mo><mn> 0.0 
</mn></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mrow><mi> vc.n.i 
</mi></mrow><mo>+</mo><mrow><mo>(</mo><mrow><mo>&#8722;</mo><mrow><mi> st.i_ion 
</mi></mrow></mrow><mo>&#8722;</mo><mrow><mi> l2.i 
</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8801;</mo><mn> 0.0 
</mn></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi> l2.v 
</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mi> l2.i 
</mi></mrow><mo>/</mo><mrow><mi> l2.c 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> vc.within_pulse 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mi> time 
</mi></mrow><mo>&#8722;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.tp_last 
</mi></mrow><mo>)</mo></mrow></mrow></mrow><mo>&lt;</mo><mrow><mi> vc.d_pulse 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> vc.after_pulse 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mi> time 
</mi></mrow><mo>&#8722;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.tp_last 
</mi></mrow><mo>)</mo></mrow></mrow></mrow><mo>&gt;</mo><mrow><mi> vc.d_pulse 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition1 
</mi></mrow><mo>&#8801;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition2 
</mi></mrow><mo>&#8801;</mo><mrow><mi> vc.pulse_start 
</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition3 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>&#8800;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow><mo>&#8743;</mo><mrow><mi> vc.after_pulse 
</mi></mrow><mo>)</mo></mrow><mo>&#8744;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition4 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>&#8800;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow><mo>&#8743;</mo><mrow><mi> vc.within_pulse 
</mi></mrow><mo>)</mo></mrow><mo>&#8744;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow></mrow>
</math>
<li>Within group st (prefix _ indicates shortened variable name)
<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi>_act.n</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mi>_act.steady</mi></mrow><mo>&#8722;</mo><mrow><mi>_act.n</mi></mrow><mo>)</mo></mrow><mo>/</mo><mrow><mi>_act.tau</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_open_ratio</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_act.n</mi></mrow><mo>&sdot;</mo><mrow><mi>_inact.n</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_i_open</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_g_max</mi></mrow><mo>&sdot;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>&#8722;</mo><mrow><mi>_v_eq</mi></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_i_ion</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_open_ratio</mi></mrow><mo>&sdot;</mo><mrow><mi>_i_open</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_g</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_open_ratio</mi></mrow><mo>&sdot;</mo><mrow><mi>_g_max</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_act.steady</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>fsteady</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> -0.0491 
</mn><mo>,</mo><mn> 111.358574610245 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_act.tau</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>ftau</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact.alpha</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>inact.falpha</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact.beta</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>inact.fbeta</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li>Within group inact (prefix _ indicates shortened variable name)
<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi>_n</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mrow><mi>_alpha</mi></mrow><mo>&sdot;</mo><mrow><mo>(</mo><mn> 1.0 
</mn><mo>&#8722;</mo><mrow><mi>_n</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8722;</mo><mrow><mrow><mi>_beta</mi></mrow><mo>&sdot;</mo><mrow><mi>_n</mi></mrow></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_steady</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_alpha</mi></mrow><mo>/</mo><mrow><mo>(</mo><mrow><mi>_alpha</mi></mrow><mo>+</mo><mrow><mi>_beta</mi></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_tau</mi></mrow><mo>&#8801;</mo><mrow><mn> 1.0 
</mn><mo>/</mo><mrow><mo>(</mo><mrow><mi>_alpha</mi></mrow><mo>+</mo><mrow><mi>_beta</mi></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
</ol>

</ol>

<li>Within group vc (prefix _ indicates shortened variable name)
<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mrow><mi>_g.p.i</mi></mrow><mo>+</mo><mrow><mo>(</mo><mrow><mi>_i</mi></mrow><mo>&#8722;</mo><mrow><mi>_n.i</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8801;</mo><mn> 0.0 
</mn></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> l2.v 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mo>&#8475;</mo><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi>_pulse_signal</mi></mrow><mo>)</mo></mrow></mrow><mo>&sdot;</mo><mrow><mo>(</mo><mrow><mi>_v_pulse</mi></mrow><mo>&#8722;</mo><mrow><mi>_v_hold</mi></mrow><mo>)</mo></mrow></mrow><mo>+</mo><mrow><mi>_v_hold</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_pulse_start</mi></mrow><mo>&#8801;</mo><mrow><sample/><mo>&#8289;</mo><mrow><mo>(</mo><mn> 1 
</mn><mo>,</mo><mrow><mi>_d_hold</mi></mrow><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_pulse_end</mi></mrow><mo>&#8801;</mo><mrow><sample/><mo>&#8289;</mo><mrow><mo>(</mo><mn> 2 
</mn><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_peak_indicator</mi></mrow><mo>&#8801;</mo><mrow><mrow><msup><mrow><mrow><mi>_i</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#215;</mo><mn> 1000000000000.0 
</mn></mrow><mo>&lt;</mo><mn> 0.0 
</mn></mrow></mrow>
</math>
</ol>

</ol>
<p>Functions:</p><pre><code class="language-modelica">function fa
  input Real x &quot;input value&quot;;
  input Real off = 0.0 &quot;offset added to result to increase minimum (fitting parameter)&quot;;
  output Real y &quot;result of applying the HH-style equation tau = 1/(alpha + beta)&quot;;
algorithm
  y := 1.0 / (fa.falpha(x, 0.0, -1000.0 / 10.0, 95.0 / 150.4) + fa.falpha(x, 0.0, -1000.0 / 700.0, 50.0 / 150.4)) + off;
end fa;</code></pre><pre><code class="language-modelica">function fsteady
  input Real x &quot;input value&quot;;
  input Real y_min = 0.0 &quot;lower asymptote (fitting parameter)&quot;;
  input Real y_max = 1.0 &quot;upper asmyptote when d_off=1 and nu=1 (fititng parameter)&quot;;
  input Real x0 = -0.0491 &quot;x-value of sigmoid midpoint when d_off=1 and nu=1 (fitting parameter)&quot;;
  input Real sx = 111.358574610245 &quot;scaling factor for x axis (i.e. steepness, fitting parameter)&quot;;
  input Real se = 1.0 &quot;scaling factor for exponential part (fitting parameter)&quot;;
  input Real d_off = 1.0 &quot;offset in denominator (affects upper asymptote, fitting parameter)&quot;;
  input Real nu = 1.0 &quot;reciprocal of exponent of denominator (affects upper asymptote, fitting parameter)&quot;;
  output Real y &quot;result&quot;;
  protected Real x_adj &quot;adjusted x with offset and scaling factor&quot;;
algorithm
  x_adj := sx * (x - x0);
  y := y_min + (y_max - y_min) / (se * exp(-x_adj) + d_off) ^ (1.0 / nu);
end fsteady;</code></pre><pre><code class="language-modelica">function inact.falpha
  input Real x &quot;input value&quot;;
  input Real off = 0.0 &quot;offset added to result to increase minimum (fitting parameter)&quot;;
  output Real y &quot;result of applying the HH-style equation tau = 1/(alpha + beta)&quot;;
algorithm
  y := 1.0 / (fa.falpha(x, 0.0, 1000.0 / 13.0, 3100.0 / 150.4) + fa.falpha(x, 0.0, 1000.0 / 70.0, 700.0 / 150.4)) + off;
end inact.falpha;</code></pre><pre><code class="language-modelica">function ftau.falpha
  input Real x &quot;input value&quot;;
  input Real off = 0.0 &quot;offset added to result to increase minimum (fitting parameter)&quot;;
  output Real y &quot;result of applying the HH-style equation tau = 1/(alpha + beta)&quot;;
algorithm
  y := 1.0 / (fa.falpha(x, 0.0, -1000.0 / 11.0, 0.00015) + fa.falpha(x, 0.0, -1000.0 / 700.0, 0.0002)) + off;
end ftau.falpha;</code></pre><pre><code class="language-modelica">function absmax &quot;returns input whose absolute value is larger, preserving the sign&quot;
  input Real a &quot;first input&quot;;
  input Real b &quot;second input&quot;;
  output Real m &quot;a if abs(a) &gt; abs(b), otherwise b&quot;;
algorithm
  m := if abs(a) &gt; abs(b) then a else b;
end absmax;</code></pre><pre><code class="language-modelica">function ftau.fbeta
  input Real x &quot;input value&quot;;
  input Real off = 0.0 &quot;offset added to result to increase minimum (fitting parameter)&quot;;
  output Real y &quot;result of applying the HH-style equation tau = 1/(alpha + beta)&quot;;
algorithm
  y := 1.0 / (fa.falpha(x, 0.0, 1000.0 / 8.0, 0.016) + fa.falpha(x, 0.0, 1000.0 / 50.0, 0.015)) + off;
end ftau.fbeta;</code></pre><pre><code class="language-modelica">function fa.falpha
  input Real x &quot;input value&quot;;
  input Real x0 = 0.0 &quot;x-value where y = 1 (fitting parameter)&quot;;
  input Real sx = -100.0 &quot;scaling factor for x axis (fitting parameter)&quot;;
  input Real sy = 0.6316489361702128 &quot;scaling factor for y axis (fitting parameter)&quot;;
  output Real y &quot;result&quot;;
algorithm
  y := sy * exp(sx * (x - x0));
end fa.falpha;</code></pre><pre><code class="language-modelica">function ftau
  input Real x &quot;input value&quot;;
  input Real off = 0.0 &quot;offset added to result to increase minimum (fitting parameter)&quot;;
  output Real y &quot;result of applying the HH-style equation tau = 1/(alpha + beta)&quot;;
algorithm
  y := 1.0 / (ftau.falpha(x, 0.0) + ftau.fbeta(x, 0.0)) + off;
end ftau;</code></pre><pre><code class="language-modelica">function inact.fbeta
  input Real x &quot;input value&quot;;
  output Real y &quot;output value&quot;;
algorithm
  y := fa(x, 0.0) + fsteady(x, 0.0, 0.229, 0.0, 1000.0 / 5.0, 1.0, 1.0, 1.0);
end inact.fbeta;</code></pre><table><tr><th style="text-align: right">name</th><th style="text-align: right">unit</th><th style="text-align: right">value</th><th style="text-align: right">label</th></tr><tr><td style="text-align: right">l2.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing from pin p to pin n</td></tr><tr><td style="text-align: right">l2.v</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right"></td><td style="text-align: right">Voltage drop of the two pins (= p.v - n.v)</td></tr><tr><td style="text-align: right">st.inact.tau</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right"></td><td style="text-align: right">time constant for obtaining steady state (i.e. time until difference between n and steady has reduced by a factor of 1/e)</td></tr><tr><td style="text-align: right">st.inact.steady</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right"></td><td style="text-align: right">steady state achieved if current voltage is held constant</td></tr><tr><td style="text-align: right">st.inact.beta</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right"></td><td style="text-align: right">rate of transfer from open to closed conformation</td></tr><tr><td style="text-align: right">st.inact.alpha</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right"></td><td style="text-align: right">rate of transfer from closed to open conformation</td></tr><tr><td style="text-align: right">st.inact.n</td><td style="text-align: right"></td><td style="text-align: right">0.03322275838167021</td><td style="text-align: right">ratio of molecules in open conformation</td></tr><tr><td style="text-align: right">st.act.tau</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right"></td><td style="text-align: right">time constant for obtaining steady state (i.e. time until difference between n and steady has reduced by a factor of 1/e)</td></tr><tr><td style="text-align: right">st.act.steady</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">value that n would reach if v_gate was held constant</td></tr><tr><td style="text-align: right">st.act.n</td><td style="text-align: right"></td><td style="text-align: right">0.9957968373875523</td><td style="text-align: right">ratio of molecules in open conformation</td></tr><tr><td style="text-align: right">st.g</td><td style="text-align: right">&quot;S&quot;</td><td style="text-align: right"></td><td style="text-align: right">ion conductance</td></tr><tr><td style="text-align: right">st.i_open</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">i if open_ratio = 1</td></tr><tr><td style="text-align: right">st.open_ratio</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right"></td><td style="text-align: right">ratio between 0 (fully closed) and 1 (fully open)</td></tr><tr><td style="text-align: right">st.i_ion</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">current used for ion flux</td></tr><tr><td style="text-align: right">vc.after_pulse</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">true after pulse has passed</td></tr><tr><td style="text-align: right">vc.within_pulse</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">true during pulse</td></tr><tr><td style="text-align: right">vc.vp_last</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">voltage of last pulse</td></tr><tr><td style="text-align: right">vc.tp_last</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">time stamp of start of last pulse</td></tr><tr><td style="text-align: right">vc.peak_indicator</td><td style="text-align: right"></td><td style="text-align: right">false</td><td style="text-align: right">forces event at peak (factor of 1e12 is required to detect zero crossing)</td></tr><tr><td style="text-align: right">vc.tail_i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">peak current after pulse</td></tr><tr><td style="text-align: right">vc.peak_i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">peak current during pulse</td></tr><tr><td style="text-align: right">vc.vs_tail</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_tail</td></tr><tr><td style="text-align: right">vc.vs_end</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_end</td></tr><tr><td style="text-align: right">vc.vs_peak</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_peak</td></tr><tr><td style="text-align: right">vc.is_end</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of current at end of last pulse</td></tr><tr><td style="text-align: right">vc.is_tail</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of peak tail current after last pulse</td></tr><tr><td style="text-align: right">vc.is_peak</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of peak current during last pulse</td></tr><tr><td style="text-align: right">vc.v_pulse</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right"></td><td style="text-align: right">voltage during pulse (must be defined externally)</td></tr><tr><td style="text-align: right">vc.pulse_signal</td><td style="text-align: right"></td><td style="text-align: right">0</td><td style="text-align: right">0 during holding period, 1 during pulse</td></tr><tr><td style="text-align: right">vc.pulse_end</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">signals end of pulse</td></tr><tr><td style="text-align: right">vc.pulse_start</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">signals start of pulse</td></tr><tr><td style="text-align: right">vc.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">measured membrane current</td></tr><tr><td style="text-align: right">vc.g.p.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing into the pin</td></tr><tr><td style="text-align: right">vc.n.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing into the pin</td></tr><tr><td style="text-align: right">$whenCondition1</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.pulse_end</td></tr><tr><td style="text-align: right">$whenCondition2</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.pulse_start</td></tr><tr><td style="text-align: right">$whenCondition3</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.peak_indicator &lt;&gt; pre(vc.peak_indicator) and vc.after_pulse or vc.pulse_end</td></tr><tr><td style="text-align: right">$whenCondition4</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.peak_indicator &lt;&gt; pre(vc.peak_indicator) and vc.within_pulse or vc.pulse_end</td></tr><tr><td style="text-align: right">vc.g.p.v</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">Potential at the pin</td></tr><tr><td style="text-align: right">vc.d_hold</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">15.0</td><td style="text-align: right">holding period</td></tr><tr><td style="text-align: right">vc.d_pulse</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">0.5</td><td style="text-align: right">pulse period</td></tr><tr><td style="text-align: right">vc.v_hold</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.08</td><td style="text-align: right">voltage during holding period</td></tr><tr><td style="text-align: right">v_start</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.08</td><td style="text-align: right">start value for pulse amplitude</td></tr><tr><td style="text-align: right">v_inc</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.005</td><td style="text-align: right">increment for pulse amplitude</td></tr><tr><td style="text-align: right">st.v_eq</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0374</td><td style="text-align: right">equilibrium potential</td></tr><tr><td style="text-align: right">st.g_max</td><td style="text-align: right">&quot;S&quot;</td><td style="text-align: right">2.7e-10</td><td style="text-align: right">maximum conductance</td></tr><tr><td style="text-align: right">st.current_name</td><td style="text-align: right"></td><td style="text-align: right">&quot;I_st&quot;</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">l2.c</td><td style="text-align: right">&quot;F&quot;</td><td style="text-align: right">2.9e-11</td><td style="text-align: right">membrane capacitance</td></tr><tr><td style="text-align: right">l2.v_init</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.09</td><td style="text-align: right">initial potential (from short initial stimulation)</td></tr><tr><td style="text-align: right">l2.use_init</td><td style="text-align: right"></td><td style="text-align: right">false</td><td style="text-align: right">determines whether initial value for v is used</td></tr></table>
    <p>This example is identical to SustainedInwardIV with the exception that
    the equation for the steady state of the activation and the parameter
    values for g_max and C are taken from Kurata 2002.</p>
    <p>To reproduce Figure 4 bottom left from Kurata 2002, plot vc.i against
    time starting 50 ms before and ending 100 ms after the pulses with amplitude
    -70 to 50 mV (in 10 mV increments).</p>
    <p>To reproduce Figure 4 bottom right from Kurata 2002, plot vc.is_peak / C
    against vc.vs_peak.
    It is necessary to use vc.vs_peak instead of vc.v_pulse, because vc.is_peak
    captures the current from the <i>previous</i> pulse.</p>
    <p>Simulation protocol and parameters are chosen with the same rationale
    as in SustainedInwardIV.</p>
    <pre><code class="language-modelica">model SustainedInwardIVKurata &quot;IV relationship of I_st, reproduces Figure 4 from Kurata 2002 (bottom left + bottom right)&quot;
  // FIXME redeclare breaks icon inheritance
  extends SustainedInwardIV(st(act(redeclare function fsteady = genLogistic(x0 = -57e-3, sx = 1000 / 5)), g_max = 0.48e-9), l2(c = 32e-12));
  annotation(
    experiment(StartTime = 0, StopTime = 480, Tolerance = 1e-6, Interval = 1e-2),
    __OpenModelica_simulationFlags(lv = &quot;LOG_STATS&quot;, s = &quot;dassl&quot;),
    __MoST_experiment(variableFilter = &quot;vc\\.(i|is_peak|vs_peak|v|v_pulse)&quot;),
    Documentation(info = &quot;
    &lt;html&gt;
    &lt;p&gt;This example is identical to SustainedInwardIV with the exception that
    the equation for the steady state of the activation and the parameter
    values for g_max and C are taken from Kurata 2002.&lt;/p&gt;
    &lt;p&gt;To reproduce Figure 4 bottom left from Kurata 2002, plot vc.i against
    time starting 50 ms before and ending 100 ms after the pulses with amplitude
    -70 to 50 mV (in 10 mV increments).&lt;/p&gt;
    &lt;p&gt;To reproduce Figure 4 bottom right from Kurata 2002, plot vc.is_peak / C
    against vc.vs_peak.
    It is necessary to use vc.vs_peak instead of vc.v_pulse, because vc.is_peak
    captures the current from the &lt;i&gt;previous&lt;/i&gt; pulse.&lt;/p&gt;
    &lt;p&gt;Simulation protocol and parameters are chosen with the same rationale
    as in SustainedInwardIV.&lt;/p&gt;
    &lt;/html&gt;
  &quot;));
end SustainedInwardIVKurata;</code></pre><ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mrow><mi> l2.i 
</mi></mrow><mo>+</mo><mrow><mo>(</mo><mrow><mi> st.i_ion 
</mi></mrow><mo>&#8722;</mo><mrow><mi> vc.i 
</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8801;</mo><mn> 0.0 
</mn></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mrow><mi> vc.n.i 
</mi></mrow><mo>+</mo><mrow><mo>(</mo><mrow><mo>&#8722;</mo><mrow><mi> st.i_ion 
</mi></mrow></mrow><mo>&#8722;</mo><mrow><mi> l2.i 
</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8801;</mo><mn> 0.0 
</mn></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi> l2.v 
</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mi> l2.i 
</mi></mrow><mo>/</mo><mrow><mi> l2.c 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> vc.within_pulse 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mi> time 
</mi></mrow><mo>&#8722;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.tp_last 
</mi></mrow><mo>)</mo></mrow></mrow></mrow><mo>&lt;</mo><mrow><mi> vc.d_pulse 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> vc.after_pulse 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mi> time 
</mi></mrow><mo>&#8722;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.tp_last 
</mi></mrow><mo>)</mo></mrow></mrow></mrow><mo>&gt;</mo><mrow><mi> vc.d_pulse 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition1 
</mi></mrow><mo>&#8801;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition2 
</mi></mrow><mo>&#8801;</mo><mrow><mi> vc.pulse_start 
</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition3 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>&#8800;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow><mo>&#8743;</mo><mrow><mi> vc.after_pulse 
</mi></mrow><mo>)</mo></mrow><mo>&#8744;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition4 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>&#8800;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow><mo>&#8743;</mo><mrow><mi> vc.within_pulse 
</mi></mrow><mo>)</mo></mrow><mo>&#8744;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow></mrow>
</math>
<li>Within group st (prefix _ indicates shortened variable name)
<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi>_act.n</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mi>_act.steady</mi></mrow><mo>&#8722;</mo><mrow><mi>_act.n</mi></mrow><mo>)</mo></mrow><mo>/</mo><mrow><mi>_act.tau</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_open_ratio</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_act.n</mi></mrow><mo>&sdot;</mo><mrow><mi>_inact.n</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_i_open</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_g_max</mi></mrow><mo>&sdot;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>&#8722;</mo><mrow><mi>_v_eq</mi></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_i_ion</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_open_ratio</mi></mrow><mo>&sdot;</mo><mrow><mi>_i_open</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_g</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_open_ratio</mi></mrow><mo>&sdot;</mo><mrow><mi>_g_max</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_act.steady</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>fsteady</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> -0.057 
</mn><mo>,</mo><mn> 200.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_act.tau</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>ftau</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact.alpha</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>inact.falpha</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact.beta</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>inact.fbeta</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li>Within group inact (prefix _ indicates shortened variable name)
<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi>_n</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mrow><mi>_alpha</mi></mrow><mo>&sdot;</mo><mrow><mo>(</mo><mn> 1.0 
</mn><mo>&#8722;</mo><mrow><mi>_n</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8722;</mo><mrow><mrow><mi>_beta</mi></mrow><mo>&sdot;</mo><mrow><mi>_n</mi></mrow></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_steady</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_alpha</mi></mrow><mo>/</mo><mrow><mo>(</mo><mrow><mi>_alpha</mi></mrow><mo>+</mo><mrow><mi>_beta</mi></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_tau</mi></mrow><mo>&#8801;</mo><mrow><mn> 1.0 
</mn><mo>/</mo><mrow><mo>(</mo><mrow><mi>_alpha</mi></mrow><mo>+</mo><mrow><mi>_beta</mi></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
</ol>

</ol>

<li>Within group vc (prefix _ indicates shortened variable name)
<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mrow><mi>_g.p.i</mi></mrow><mo>+</mo><mrow><mo>(</mo><mrow><mi>_i</mi></mrow><mo>&#8722;</mo><mrow><mi>_n.i</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8801;</mo><mn> 0.0 
</mn></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> l2.v 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mo>&#8475;</mo><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi>_pulse_signal</mi></mrow><mo>)</mo></mrow></mrow><mo>&sdot;</mo><mrow><mo>(</mo><mrow><mi>_v_pulse</mi></mrow><mo>&#8722;</mo><mrow><mi>_v_hold</mi></mrow><mo>)</mo></mrow></mrow><mo>+</mo><mrow><mi>_v_hold</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_pulse_start</mi></mrow><mo>&#8801;</mo><mrow><sample/><mo>&#8289;</mo><mrow><mo>(</mo><mn> 1 
</mn><mo>,</mo><mrow><mi>_d_hold</mi></mrow><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_pulse_end</mi></mrow><mo>&#8801;</mo><mrow><sample/><mo>&#8289;</mo><mrow><mo>(</mo><mn> 2 
</mn><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_peak_indicator</mi></mrow><mo>&#8801;</mo><mrow><mrow><msup><mrow><mrow><mi>_i</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#215;</mo><mn> 1000000000000.0 
</mn></mrow><mo>&lt;</mo><mn> 0.0 
</mn></mrow></mrow>
</math>
</ol>

</ol>
<p>Functions:</p><pre><code class="language-modelica">function fsteady
  input Real x &quot;input value&quot;;
  input Real y_min = 0.0 &quot;lower asymptote (fitting parameter)&quot;;
  input Real y_max = 1.0 &quot;upper asmyptote when d_off=1 and nu=1 (fititng parameter)&quot;;
  input Real x0 = -0.057 &quot;x-value of sigmoid midpoint when d_off=1 and nu=1 (fitting parameter)&quot;;
  input Real sx = 200.0 &quot;scaling factor for x axis (i.e. steepness, fitting parameter)&quot;;
  input Real se = 1.0 &quot;scaling factor for exponential part (fitting parameter)&quot;;
  input Real d_off = 1.0 &quot;offset in denominator (affects upper asymptote, fitting parameter)&quot;;
  input Real nu = 1.0 &quot;reciprocal of exponent of denominator (affects upper asymptote, fitting parameter)&quot;;
  output Real y &quot;result&quot;;
  protected Real x_adj &quot;adjusted x with offset and scaling factor&quot;;
algorithm
  x_adj := sx * (x - x0);
  y := y_min + (y_max - y_min) / (se * exp(-x_adj) + d_off) ^ (1.0 / nu);
end fsteady;</code></pre><pre><code class="language-modelica">function fa
  input Real x &quot;input value&quot;;
  input Real off = 0.0 &quot;offset added to result to increase minimum (fitting parameter)&quot;;
  output Real y &quot;result of applying the HH-style equation tau = 1/(alpha + beta)&quot;;
algorithm
  y := 1.0 / (fa.falpha(x, 0.0, -1000.0 / 10.0, 95.0 / 150.4) + fa.falpha(x, 0.0, -1000.0 / 700.0, 50.0 / 150.4)) + off;
end fa;</code></pre><pre><code class="language-modelica">function ftau.fbeta
  input Real x &quot;input value&quot;;
  input Real off = 0.0 &quot;offset added to result to increase minimum (fitting parameter)&quot;;
  output Real y &quot;result of applying the HH-style equation tau = 1/(alpha + beta)&quot;;
algorithm
  y := 1.0 / (fa.falpha(x, 0.0, 1000.0 / 8.0, 0.016) + fa.falpha(x, 0.0, 1000.0 / 50.0, 0.015)) + off;
end ftau.fbeta;</code></pre><pre><code class="language-modelica">function inact.fbeta
  input Real x &quot;input value&quot;;
  output Real y &quot;output value&quot;;
algorithm
  y := fa(x, 0.0) + fsteady(x, 0.0, 0.229, 0.0, 1000.0 / 5.0, 1.0, 1.0, 1.0);
end inact.fbeta;</code></pre><pre><code class="language-modelica">function absmax &quot;returns input whose absolute value is larger, preserving the sign&quot;
  input Real a &quot;first input&quot;;
  input Real b &quot;second input&quot;;
  output Real m &quot;a if abs(a) &gt; abs(b), otherwise b&quot;;
algorithm
  m := if abs(a) &gt; abs(b) then a else b;
end absmax;</code></pre><pre><code class="language-modelica">function inact.falpha
  input Real x &quot;input value&quot;;
  input Real off = 0.0 &quot;offset added to result to increase minimum (fitting parameter)&quot;;
  output Real y &quot;result of applying the HH-style equation tau = 1/(alpha + beta)&quot;;
algorithm
  y := 1.0 / (fa.falpha(x, 0.0, 1000.0 / 13.0, 3100.0 / 150.4) + fa.falpha(x, 0.0, 1000.0 / 70.0, 700.0 / 150.4)) + off;
end inact.falpha;</code></pre><pre><code class="language-modelica">function ftau
  input Real x &quot;input value&quot;;
  input Real off = 0.0 &quot;offset added to result to increase minimum (fitting parameter)&quot;;
  output Real y &quot;result of applying the HH-style equation tau = 1/(alpha + beta)&quot;;
algorithm
  y := 1.0 / (ftau.falpha(x, 0.0) + ftau.fbeta(x, 0.0)) + off;
end ftau;</code></pre><pre><code class="language-modelica">function fa.falpha
  input Real x &quot;input value&quot;;
  input Real x0 = 0.0 &quot;x-value where y = 1 (fitting parameter)&quot;;
  input Real sx = -100.0 &quot;scaling factor for x axis (fitting parameter)&quot;;
  input Real sy = 0.6316489361702128 &quot;scaling factor for y axis (fitting parameter)&quot;;
  output Real y &quot;result&quot;;
algorithm
  y := sy * exp(sx * (x - x0));
end fa.falpha;</code></pre><pre><code class="language-modelica">function ftau.falpha
  input Real x &quot;input value&quot;;
  input Real off = 0.0 &quot;offset added to result to increase minimum (fitting parameter)&quot;;
  output Real y &quot;result of applying the HH-style equation tau = 1/(alpha + beta)&quot;;
algorithm
  y := 1.0 / (fa.falpha(x, 0.0, -1000.0 / 11.0, 0.00015) + fa.falpha(x, 0.0, -1000.0 / 700.0, 0.0002)) + off;
end ftau.falpha;</code></pre><table><tr><th style="text-align: right">name</th><th style="text-align: right">unit</th><th style="text-align: right">value</th><th style="text-align: right">label</th></tr><tr><td style="text-align: right">l2.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing from pin p to pin n</td></tr><tr><td style="text-align: right">l2.v</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right"></td><td style="text-align: right">Voltage drop of the two pins (= p.v - n.v)</td></tr><tr><td style="text-align: right">st.inact.tau</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right"></td><td style="text-align: right">time constant for obtaining steady state (i.e. time until difference between n and steady has reduced by a factor of 1/e)</td></tr><tr><td style="text-align: right">st.inact.steady</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right"></td><td style="text-align: right">steady state achieved if current voltage is held constant</td></tr><tr><td style="text-align: right">st.inact.beta</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right"></td><td style="text-align: right">rate of transfer from open to closed conformation</td></tr><tr><td style="text-align: right">st.inact.alpha</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right"></td><td style="text-align: right">rate of transfer from closed to open conformation</td></tr><tr><td style="text-align: right">st.inact.n</td><td style="text-align: right"></td><td style="text-align: right">0.03322275838167021</td><td style="text-align: right">ratio of molecules in open conformation</td></tr><tr><td style="text-align: right">st.act.tau</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right"></td><td style="text-align: right">time constant for obtaining steady state (i.e. time until difference between n and steady has reduced by a factor of 1/e)</td></tr><tr><td style="text-align: right">st.act.steady</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">value that n would reach if v_gate was held constant</td></tr><tr><td style="text-align: right">st.act.n</td><td style="text-align: right"></td><td style="text-align: right">0.999988804640495</td><td style="text-align: right">ratio of molecules in open conformation</td></tr><tr><td style="text-align: right">st.g</td><td style="text-align: right">&quot;S&quot;</td><td style="text-align: right"></td><td style="text-align: right">ion conductance</td></tr><tr><td style="text-align: right">st.i_open</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">i if open_ratio = 1</td></tr><tr><td style="text-align: right">st.open_ratio</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right"></td><td style="text-align: right">ratio between 0 (fully closed) and 1 (fully open)</td></tr><tr><td style="text-align: right">st.i_ion</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">current used for ion flux</td></tr><tr><td style="text-align: right">vc.after_pulse</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">true after pulse has passed</td></tr><tr><td style="text-align: right">vc.within_pulse</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">true during pulse</td></tr><tr><td style="text-align: right">vc.vp_last</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">voltage of last pulse</td></tr><tr><td style="text-align: right">vc.tp_last</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">time stamp of start of last pulse</td></tr><tr><td style="text-align: right">vc.peak_indicator</td><td style="text-align: right"></td><td style="text-align: right">false</td><td style="text-align: right">forces event at peak (factor of 1e12 is required to detect zero crossing)</td></tr><tr><td style="text-align: right">vc.tail_i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">peak current after pulse</td></tr><tr><td style="text-align: right">vc.peak_i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">peak current during pulse</td></tr><tr><td style="text-align: right">vc.vs_tail</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_tail</td></tr><tr><td style="text-align: right">vc.vs_end</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_end</td></tr><tr><td style="text-align: right">vc.vs_peak</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_peak</td></tr><tr><td style="text-align: right">vc.is_end</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of current at end of last pulse</td></tr><tr><td style="text-align: right">vc.is_tail</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of peak tail current after last pulse</td></tr><tr><td style="text-align: right">vc.is_peak</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of peak current during last pulse</td></tr><tr><td style="text-align: right">vc.v_pulse</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right"></td><td style="text-align: right">voltage during pulse (must be defined externally)</td></tr><tr><td style="text-align: right">vc.pulse_signal</td><td style="text-align: right"></td><td style="text-align: right">0</td><td style="text-align: right">0 during holding period, 1 during pulse</td></tr><tr><td style="text-align: right">vc.pulse_end</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">signals end of pulse</td></tr><tr><td style="text-align: right">vc.pulse_start</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">signals start of pulse</td></tr><tr><td style="text-align: right">vc.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">measured membrane current</td></tr><tr><td style="text-align: right">vc.g.p.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing into the pin</td></tr><tr><td style="text-align: right">vc.n.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing into the pin</td></tr><tr><td style="text-align: right">$whenCondition1</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.pulse_end</td></tr><tr><td style="text-align: right">$whenCondition2</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.pulse_start</td></tr><tr><td style="text-align: right">$whenCondition3</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.peak_indicator &lt;&gt; pre(vc.peak_indicator) and vc.after_pulse or vc.pulse_end</td></tr><tr><td style="text-align: right">$whenCondition4</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.peak_indicator &lt;&gt; pre(vc.peak_indicator) and vc.within_pulse or vc.pulse_end</td></tr><tr><td style="text-align: right">vc.g.p.v</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">Potential at the pin</td></tr><tr><td style="text-align: right">vc.d_hold</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">15.0</td><td style="text-align: right">holding period</td></tr><tr><td style="text-align: right">vc.d_pulse</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">0.5</td><td style="text-align: right">pulse period</td></tr><tr><td style="text-align: right">vc.v_hold</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.08</td><td style="text-align: right">voltage during holding period</td></tr><tr><td style="text-align: right">v_start</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.08</td><td style="text-align: right">start value for pulse amplitude</td></tr><tr><td style="text-align: right">v_inc</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.005</td><td style="text-align: right">increment for pulse amplitude</td></tr><tr><td style="text-align: right">st.v_eq</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0374</td><td style="text-align: right">equilibrium potential</td></tr><tr><td style="text-align: right">st.g_max</td><td style="text-align: right">&quot;S&quot;</td><td style="text-align: right">4.8e-10</td><td style="text-align: right">maximum conductance</td></tr><tr><td style="text-align: right">st.current_name</td><td style="text-align: right"></td><td style="text-align: right">&quot;I_st&quot;</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">l2.c</td><td style="text-align: right">&quot;F&quot;</td><td style="text-align: right">3.2e-11</td><td style="text-align: right">membrane capacitance</td></tr><tr><td style="text-align: right">l2.v_init</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.09</td><td style="text-align: right">initial potential (from short initial stimulation)</td></tr><tr><td style="text-align: right">l2.use_init</td><td style="text-align: right"></td><td style="text-align: right">false</td><td style="text-align: right">determines whether initial value for v is used</td></tr></table>
      <p>To reproduce Figure S5A from Inada 2009, plot act_steady
      against v.</p>
      <p>Simulation protocol and parameters are chosen with the following
      rationale:</p>
      <ul>
        <li>StopTime: allow a plot from -80 to 60 mV</li>
        <li>Tolerance: left at default value, since derivatives are not
        relevant</li>
        <li>Interval: enough for a smooth plot</li>
      </ul>
    <pre><code class="language-modelica">model SustainedInwardSteady &quot;steady state of I_st, recreates Figure S5A from Inada 2009&quot;
  extends Modelica.Icons.Example;
  InaMo.Membrane.LipidBilayer l2(use_init = false) &quot;cell membrane&quot; annotation(
    Placement(transformation(extent = {{17, -17}, {51, 17}})));
  InaMo.ExperimentalMethods.VoltageClamp.VoltageClamp vc &quot;voltage clamp&quot; annotation(
    Placement(transformation(extent = {{-17, -17}, {17, 17}})));
  InaMo.Currents.Atrioventricular.SustainedInwardChannel st &quot;I_st&quot; annotation(
    Placement(transformation(extent = {{-51, -17}, {-17, 17}})));
  Real act_steady = st.act.steady &quot;steady state of activation gate&quot;;
  SI.Duration act_tau = st.act.tau &quot;time constant of activation gate&quot;;
  Real inact_steady = inact_tau * st.inact.alpha &quot;steady state of inactivation gate&quot;;
  SI.Duration inact_tau = 1 / (st.inact.alpha + st.inact.beta) &quot;time constant of inactivation gate&quot;;
  SI.Voltage v(start = -0.08, fixed = true) &quot;input voltage&quot;;

  function qa &quot;direct copy of activation steady state from Kurata 2002&quot;
    input Real x;
    output Real y;
  algorithm
    y := 1 / (1 + exp(-(x + 57) / 5));
  end qa;

  function qi &quot;direct copy of inactivation steady state from Kurata 2002&quot;
    input Real x;
    output Real y;
  protected
    Real alpha;
    Real beta;
  algorithm
    alpha := 0.1504 / (3100 * exp(x / 13) + 700 * exp(x / 70));
    beta := 0.1504 / (95 * exp(-x / 10) + 50 * exp(-x / 700)) + 0.000229 / (1 + exp(-x / 5));
    y := alpha / (alpha + beta);
  end qi;

  function tau_qa &quot;direct copy of activation time constant from Kurata 2002&quot;
    input Real x;
    output Real y;
  protected
    Real alpha;
    Real beta;
  algorithm
    alpha := 1 / (0.15 * exp(-x / 11) + 0.2 * exp(-x / 700));
    beta := 1 / (16 * exp(x / 8) + 15 * exp(x / 50));
    y := 1 / (alpha + beta);
  end tau_qa;

  function tau_qi &quot;direct copy of inactivation time constant from Kurata 2002&quot;
    input Real x;
    output Real y;
  protected
    Real alpha;
    Real beta;
  algorithm
    alpha := 0.1504 / (3100 * exp(x / 13) + 700 * exp(x / 70));
    beta := 0.1504 / (95 * exp(-x / 10) + 50 * exp(-x / 700)) + 0.000229 / (1 + exp(-x / 5));
    y := 1 / (alpha + beta);
  end tau_qi;

  Real act_steady2 = qa(1000 * v) &quot;steady state of activation gate (Kurata 2002)&quot;;
  Real inact_steady2 = qi(1000 * v) &quot;steady state of inactivation gate (Kurata 2002)&quot;;
  Real act_tau2 = 0.001 * tau_qa(1000 * v) &quot;time constant of activation gate (Kurata 2002)&quot;;
  Real inact_tau2 = 0.001 * tau_qi(1000 * v) &quot;steady state of inactivation gate (Kurata 2002)&quot;;
equation
  vc.v_stim = v;
  der(v) = 0.001;
  connect(l2.p, vc.p) annotation(
    Line(points = {{34, 18}, {34, 18}, {34, 40}, {0, 40}, {0, 18}, {0, 18}}, color = {0, 0, 255}));
  connect(vc.p, st.p) annotation(
    Line(points = {{0, 18}, {0, 18}, {0, 40}, {-34, 40}, {-34, 18}, {-34, 18}}, color = {0, 0, 255}));
  connect(l2.n, vc.n) annotation(
    Line(points = {{34, -16}, {34, -16}, {34, -40}, {0, -40}, {0, -16}, {0, -16}}, color = {0, 0, 255}));
  connect(vc.n, st.n) annotation(
    Line(points = {{0, -16}, {0, -16}, {0, -40}, {-34, -40}, {-34, -16}, {-34, -16}}, color = {0, 0, 255}));
  annotation(
    experiment(StartTime = 0, StopTime = 140, Tolerance = 1e-6, Interval = 1),
    __OpenModelica_simulationFlags(lv = &quot;LOG_STATS&quot;, s = &quot;dassl&quot;),
    __MoST_experiment(variableFilter = &quot;(act_steady|act_tau|inact_steady|inact_tau)2?|v|vc.v&quot;),
    Documentation(info = &quot;
    &lt;html&gt;
      &lt;p&gt;To reproduce Figure S5A from Inada 2009, plot act_steady
      against v.&lt;/p&gt;
      &lt;p&gt;Simulation protocol and parameters are chosen with the following
      rationale:&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;StopTime: allow a plot from -80 to 60 mV&lt;/li&gt;
        &lt;li&gt;Tolerance: left at default value, since derivatives are not
        relevant&lt;/li&gt;
        &lt;li&gt;Interval: enough for a smooth plot&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/html&gt;
  &quot;));
end SustainedInwardSteady;</code></pre><h2 id="Tests-for-I_{to}"><a class="docs-heading-anchor" href="#Tests-for-I_{to}">Tests for <span>$I_{to}$</span></a><a id="Tests-for-I_{to}-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-for-I_{to}" title="Permalink"></a></h2>
    <p>To reproduce Figure S2E from Inada 2009, plot vc.i against time for
    500 ms after the pulses with amplitude -10, 0, 20 and 40 mV.</p>
    <p>To reproduce Figure S2F from Inada 2009, plot vc.is_peak/max(vc.is_peak)
    against vc.vs_peak.
    It is necessary to use vc.vs_peak instead of vc.v_pulse,
    because vc.is_peak captures the current from the <i>previous</i> pulse.</p>
    <p>Simulation protocol and parameters are chosen with the following
    rationale:</p>
    <ul>
      <li>StopTime: allow a plot from -60 mV to 60 mV (NOTE: It is important
      to choose StopTime such that the pulse for 65 mV is not part of the
      simulation, because otherwise the normalized current would change, since
      the maximum current is achieved during the last pulse)</li>
      <li>Tolerance: default value</li>
      <li>Interval: enough to roughly plot time course of current</li>
      <li>d_pulse: according to description of Figure S2 in Inada 2009</li>
      <li>d_hold: approximately 5 * max(inact_slow.tau)</li>
      <li>v_hold: according to description of Figure S2 in Inada 2009</li>
      <li>l2.C: according to Table S15 in Inada 2009 (NH cell model)</li>
      <li>to.g_max: according to Table S15 in Inada 2009 (NH cell model)</li>
    </ul>
    <p>NOTE: Although Inada et al. state that they used the AN cell model for
    Figure S2E and S2F, the absolute values of the current make it seem more
    likely, that the NH cell model was used instead.
    However, with these parameters the model still shows too high absolute
    values for the current.
    We see two possible explanations for this difference: Either Inada et al.
    used differnet parameter settings for the plots without documenting them
    or they chose d_hold too small, so that recovery to the steady state at
    holding potential was not completed before the next pulse.
    The difference disappears when the current is multiplied by a factor of
    0.75 (e.g. by adjusting g_max).</p>
    <pre><code class="language-modelica">model TransientOutwardIV &quot;IV relationship of I_to, recreates Figures S2E and S2F from Inada 2009&quot;
  extends Modelica.Icons.Example;
  extends InaMo.Examples.Interfaces.IVBase(vc(v_hold = -0.08, d_hold = 20, d_pulse = 0.5), v_start = -0.06, v_inc = 0.005);
  parameter SI.Concentration k_in = 140 &quot;intracellular potassium concentration&quot;;
  parameter SI.Concentration k_ex = 5.4 &quot;extracellular potassium concentration&quot;;
  parameter SI.Temperature temp = 310 &quot;cell medium temperature&quot;;
  parameter SI.Voltage v_k = nernst(k_in, k_ex, 1, temp) &quot;equilibrium potential for K+ ions&quot;;
  InaMo.Currents.Atrioventricular.TransientOutwardChannel to(g_max = 14e-9, v_eq = v_k) &quot;I_to (parameter values for NH cell)&quot; annotation(
    Placement(transformation(extent = {{-51, -17}, {-17, 17}})));
  // use g_max of NH model
  InaMo.Membrane.LipidBilayer l2(use_init = false, c = 40e-12) &quot;cell membrane&quot; annotation(
    Placement(transformation(extent = {{17, -17}, {51, 17}})));
equation
  connect(l2.p, vc.p) annotation(
    Line(points = {{34, 18}, {34, 18}, {34, 40}, {0, 40}, {0, 18}, {0, 18}}, color = {0, 0, 255}));
  connect(vc.p, to.p) annotation(
    Line(points = {{0, 18}, {0, 18}, {0, 40}, {-34, 40}, {-34, 18}, {-34, 18}}, color = {0, 0, 255}));
  connect(l2.n, vc.n) annotation(
    Line(points = {{34, -16}, {34, -16}, {34, -40}, {0, -40}, {0, -16}, {0, -16}}, color = {0, 0, 255}));
  connect(vc.n, to.n) annotation(
    Line(points = {{0, -16}, {0, -16}, {0, -40}, {-34, -40}, {-34, -16}, {-34, -16}}, color = {0, 0, 255}));
  annotation(
    experiment(StartTime = 0, StopTime = 532.5, Tolerance = 1e-6, Interval = 1e-2),
    __MoST_experiment(variableFilter = &quot;vc\\.(i|is_peak|vs_peak|v|v_pulse)&quot;),
    __OpenModelica_simulationFlags(lv = &quot;LOG_STATS&quot;, s = &quot;dassl&quot;),
    Documentation(info = &quot;
    &lt;html&gt;
    &lt;p&gt;To reproduce Figure S2E from Inada 2009, plot vc.i against time for
    500 ms after the pulses with amplitude -10, 0, 20 and 40 mV.&lt;/p&gt;
    &lt;p&gt;To reproduce Figure S2F from Inada 2009, plot vc.is_peak/max(vc.is_peak)
    against vc.vs_peak.
    It is necessary to use vc.vs_peak instead of vc.v_pulse,
    because vc.is_peak captures the current from the &lt;i&gt;previous&lt;/i&gt; pulse.&lt;/p&gt;
    &lt;p&gt;Simulation protocol and parameters are chosen with the following
    rationale:&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;StopTime: allow a plot from -60 mV to 60 mV (NOTE: It is important
      to choose StopTime such that the pulse for 65 mV is not part of the
      simulation, because otherwise the normalized current would change, since
      the maximum current is achieved during the last pulse)&lt;/li&gt;
      &lt;li&gt;Tolerance: default value&lt;/li&gt;
      &lt;li&gt;Interval: enough to roughly plot time course of current&lt;/li&gt;
      &lt;li&gt;d_pulse: according to description of Figure S2 in Inada 2009&lt;/li&gt;
      &lt;li&gt;d_hold: approximately 5 * max(inact_slow.tau)&lt;/li&gt;
      &lt;li&gt;v_hold: according to description of Figure S2 in Inada 2009&lt;/li&gt;
      &lt;li&gt;l2.C: according to Table S15 in Inada 2009 (NH cell model)&lt;/li&gt;
      &lt;li&gt;to.g_max: according to Table S15 in Inada 2009 (NH cell model)&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;NOTE: Although Inada et al. state that they used the AN cell model for
    Figure S2E and S2F, the absolute values of the current make it seem more
    likely, that the NH cell model was used instead.
    However, with these parameters the model still shows too high absolute
    values for the current.
    We see two possible explanations for this difference: Either Inada et al.
    used differnet parameter settings for the plots without documenting them
    or they chose d_hold too small, so that recovery to the steady state at
    holding potential was not completed before the next pulse.
    The difference disappears when the current is multiplied by a factor of
    0.75 (e.g. by adjusting g_max).&lt;/p&gt;
    &lt;/html&gt;
  &quot;));
end TransientOutwardIV;</code></pre><ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mrow><mi> l2.i 
</mi></mrow><mo>+</mo><mrow><mo>(</mo><mrow><mi> to.i_ion 
</mi></mrow><mo>&#8722;</mo><mrow><mi> vc.i 
</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8801;</mo><mn> 0.0 
</mn></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi> l2.v 
</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mi> l2.i 
</mi></mrow><mo>/</mo><mrow><mi> l2.c 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> vc.within_pulse 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mi> time 
</mi></mrow><mo>&#8722;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.tp_last 
</mi></mrow><mo>)</mo></mrow></mrow></mrow><mo>&lt;</mo><mrow><mi> vc.d_pulse 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> vc.after_pulse 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mi> time 
</mi></mrow><mo>&#8722;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.tp_last 
</mi></mrow><mo>)</mo></mrow></mrow></mrow><mo>&gt;</mo><mrow><mi> vc.d_pulse 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition1 
</mi></mrow><mo>&#8801;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition2 
</mi></mrow><mo>&#8801;</mo><mrow><mi> vc.pulse_start 
</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition3 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>&#8800;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow><mo>&#8743;</mo><mrow><mi> vc.after_pulse 
</mi></mrow><mo>)</mo></mrow><mo>&#8744;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> $whenCondition4 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>&#8800;</mo><mrow><pre/><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> vc.peak_indicator 
</mi></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow><mo>&#8743;</mo><mrow><mi> vc.within_pulse 
</mi></mrow><mo>)</mo></mrow><mo>&#8744;</mo><mrow><mi> vc.pulse_end 
</mi></mrow></mrow></mrow>
</math>
<li>Within group to (prefix _ indicates shortened variable name)
<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi>_act.n</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mi>_act.steady</mi></mrow><mo>&#8722;</mo><mrow><mi>_act.n</mi></mrow><mo>)</mo></mrow><mo>/</mo><mrow><mi>_act.tau</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi>_inact_slow.n</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mi>_inact_slow.steady</mi></mrow><mo>&#8722;</mo><mrow><mi>_inact_slow.n</mi></mrow><mo>)</mo></mrow><mo>/</mo><mrow><mi>_inact_slow.tau</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><msup><mrow><mrow><mi>_inact_fast.n</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#8801;</mo><mrow><mrow><mo>(</mo><mrow><mi>_inact_fast.steady</mi></mrow><mo>&#8722;</mo><mrow><mi>_inact_fast.n</mi></mrow><mo>)</mo></mrow><mo>/</mo><mrow><mi>_inact_fast.tau</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_open_ratio</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_act.n</mi></mrow><mo>&sdot;</mo><mrow><mi>_inact_total</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_i_open</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_g_max</mi></mrow><mo>&sdot;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>&#8722;</mo><mrow><mi>_v_eq</mi></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_i_ion</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_open_ratio</mi></mrow><mo>&sdot;</mo><mrow><mi>_i_open</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_g</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>_open_ratio</mi></mrow><mo>&sdot;</mo><mrow><mi>_g_max</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_act.steady</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>fsteady</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 0.00744 
</mn><mo>,</mo><mn> 60.97560975609757 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_act.tau</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>act.ftau</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.000596 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact_slow.steady</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>fsteady</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> -0.0338 
</mn><mo>,</mo><mn> -163.3986928104575 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact_slow.tau</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>inact_slow.ftau</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.1 
</mn><mo>,</mo><mn> 4.1 
</mn><mo>,</mo><mn> -0.065 
</mn><mo>,</mo><mn> 0.0158113883008419 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact_fast.steady</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>fsteady</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> -0.0338 
</mn><mo>,</mo><mn> -163.3986928104575 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact_fast.tau</mi></mrow><mo>&#8801;</mo><mrow><mrow><mi>fsteady</mi></mrow><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi> l2.v 
</mi></mrow><mo>,</mo><mn> 0.01266 
</mn><mo>,</mo><mn> 4.73982 
</mn><mo>,</mo><mn> -0.1545 
</mn><mo>,</mo><mn> -41.73622704507513 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>,</mo><mn> 1.0 
</mn><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_inact_total</mi></mrow><mo>&#8801;</mo><mrow><mrow><mn> 0.55 
</mn><mo>&sdot;</mo><mrow><mi>_inact_slow.n</mi></mrow></mrow><mo>+</mo><mrow><mn> 0.45 
</mn><mo>&sdot;</mo><mrow><mi>_inact_fast.n</mi></mrow></mrow></mrow></mrow>
</math>
</ol>

<li>Within group vc (prefix _ indicates shortened variable name)
<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mrow><mi>_g.p.i</mi></mrow><mo>+</mo><mrow><mo>(</mo><mrow><mi>_i</mi></mrow><mo>&#8722;</mo><mrow><mi>_n.i</mi></mrow><mo>)</mo></mrow></mrow><mo>&#8801;</mo><mn> 0.0 
</mn></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_i</mi></mrow><mo>&#8801;</mo><mrow><mi>_n.i</mi></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi> l2.v 
</mi></mrow><mo>&#8801;</mo><mrow><mrow><mrow><mo>&#8475;</mo><mo>&#8289;</mo><mrow><mo>(</mo><mrow><mi>_pulse_signal</mi></mrow><mo>)</mo></mrow></mrow><mo>&sdot;</mo><mrow><mo>(</mo><mrow><mi>_v_pulse</mi></mrow><mo>&#8722;</mo><mrow><mi>_v_hold</mi></mrow><mo>)</mo></mrow></mrow><mo>+</mo><mrow><mi>_v_hold</mi></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_pulse_start</mi></mrow><mo>&#8801;</mo><mrow><sample/><mo>&#8289;</mo><mrow><mo>(</mo><mn> 1 
</mn><mo>,</mo><mrow><mi>_d_hold</mi></mrow><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_pulse_end</mi></mrow><mo>&#8801;</mo><mrow><sample/><mo>&#8289;</mo><mrow><mo>(</mo><mn> 2 
</mn><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>,</mo><mrow><mrow><mi>_d_hold</mi></mrow><mo>+</mo><mrow><mi>_d_pulse</mi></mrow></mrow><mo>)</mo></mrow></mrow></mrow>
</math>
<li><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow><mrow><mi>_peak_indicator</mi></mrow><mo>&#8801;</mo><mrow><mrow><msup><mrow><mrow><mi>_i</mi></mrow></mrow><mo>&#8242;</mo></msup><mo>&#215;</mo><mn> 1000000000000.0 
</mn></mrow><mo>&lt;</mo><mn> 0.0 
</mn></mrow></mrow>
</math>
</ol>

</ol>
<p>Functions:</p><pre><code class="language-modelica">function fsteady
  input Real x &quot;input value&quot;;
  input Real y_min = 0.0 &quot;lower asymptote (fitting parameter)&quot;;
  input Real y_max = 1.0 &quot;upper asmyptote when d_off=1 and nu=1 (fititng parameter)&quot;;
  input Real x0 = 0.00744 &quot;x-value of sigmoid midpoint when d_off=1 and nu=1 (fitting parameter)&quot;;
  input Real sx = 60.97560975609757 &quot;scaling factor for x axis (i.e. steepness, fitting parameter)&quot;;
  input Real se = 1.0 &quot;scaling factor for exponential part (fitting parameter)&quot;;
  input Real d_off = 1.0 &quot;offset in denominator (affects upper asymptote, fitting parameter)&quot;;
  input Real nu = 1.0 &quot;reciprocal of exponent of denominator (affects upper asymptote, fitting parameter)&quot;;
  output Real y &quot;result&quot;;
  protected Real x_adj &quot;adjusted x with offset and scaling factor&quot;;
algorithm
  x_adj := sx * (x - x0);
  y := y_min + (y_max - y_min) / (se * exp(-x_adj) + d_off) ^ (1.0 / nu);
end fsteady;</code></pre><pre><code class="language-modelica">function nernst &quot;Nernst equation to find the equlibrium potential for a single ion&quot;
  input Real ion_in(quantity = &quot;Concentration&quot;, unit = &quot;mol/m3&quot;) &quot;intracellular ion concentration&quot;;
  input Real ion_ex(quantity = &quot;Concentration&quot;, unit = &quot;mol/m3&quot;) &quot;extracellular ion concentration&quot;;
  input Integer ion_z &quot;valence of ion&quot;;
  input Real temp(quantity = &quot;ThermodynamicTemperature&quot;, unit = &quot;K&quot;, displayUnit = &quot;degC&quot;, min = 0.0, start = 288.15, nominal = 300.0) &quot;cell medium temperature&quot;;
  output Real v_eq(quantity = &quot;ElectricPotential&quot;, unit = &quot;V&quot;) &quot;equlibirium potential&quot;;
algorithm
  v_eq := 8.3144598 * temp / /*Real*/(ion_z) / 96485.33289000001 * log(ion_ex / ion_in);
end nernst;</code></pre><pre><code class="language-modelica">function absmax &quot;returns input whose absolute value is larger, preserving the sign&quot;
  input Real a &quot;first input&quot;;
  input Real b &quot;second input&quot;;
  output Real m &quot;a if abs(a) &gt; abs(b), otherwise b&quot;;
algorithm
  m := if abs(a) &gt; abs(b) then a else b;
end absmax;</code></pre><pre><code class="language-modelica">function act.ftau
  input Real x &quot;input value&quot;;
  input Real off = 0.000596 &quot;offset added to result to increase minimum (fitting parameter)&quot;;
  output Real y &quot;result of applying the HH-style equation tau = 1/(alpha + beta)&quot;;
algorithm
  y := 1.0 / (falpha(x, -0.03061, 90.0, 1.037 / 0.003188) + falpha(x, -0.02384, -120.0, 0.396 / 0.003188)) + off;
end act.ftau;</code></pre><pre><code class="language-modelica">function falpha
  input Real x &quot;input value&quot;;
  input Real x0 = -0.03061 &quot;x-value where y = 1 (fitting parameter)&quot;;
  input Real sx = 90.0 &quot;scaling factor for x axis (fitting parameter)&quot;;
  input Real sy = 325.2823086574655 &quot;scaling factor for y axis (fitting parameter)&quot;;
  output Real y &quot;result&quot;;
algorithm
  y := sy * exp(sx * (x - x0));
end falpha;</code></pre><pre><code class="language-modelica">function inact_slow.ftau
  input Real x &quot;input value&quot;;
  input Real y_min = 0.1 &quot;minimum value achieved at edges (fitting parameter)&quot;;
  input Real y_max = 4.1 &quot;maximum value achieved at peak (fititng parameter)&quot;;
  input Real x0 = -0.065 &quot;x-value of bell curve midpoint (fitting parameter)&quot;;
  input Real sigma = 0.0158113883008419 &quot;standard deviation determining the width of the bell curve (fitting parameter)&quot;;
  output Real y &quot;result&quot;;
  protected Real x_adj &quot;adjusted x with offset and standard deviation&quot;;
algorithm
  x_adj := (x - x0) / sigma;
  y := y_min + (y_max - y_min) * exp(-0.5 * x_adj ^ 2.0);
end inact_slow.ftau;</code></pre><table><tr><th style="text-align: right">name</th><th style="text-align: right">unit</th><th style="text-align: right">value</th><th style="text-align: right">label</th></tr><tr><td style="text-align: right">l2.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing from pin p to pin n</td></tr><tr><td style="text-align: right">l2.v</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right"></td><td style="text-align: right">Voltage drop of the two pins (= p.v - n.v)</td></tr><tr><td style="text-align: right">to.inact_total</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">total inactivation resulting from fast and slow inactivation gates</td></tr><tr><td style="text-align: right">to.inact_fast.tau</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right"></td><td style="text-align: right">time constant for obtaining steady state (i.e. time until difference between n and steady has reduced by a factor of 1/e)</td></tr><tr><td style="text-align: right">to.inact_fast.steady</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">value that n would reach if v_gate was held constant</td></tr><tr><td style="text-align: right">to.inact_fast.n</td><td style="text-align: right"></td><td style="text-align: right">0.003978453093609672</td><td style="text-align: right">ratio of molecules in open conformation</td></tr><tr><td style="text-align: right">to.inact_slow.tau</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right"></td><td style="text-align: right">time constant for obtaining steady state (i.e. time until difference between n and steady has reduced by a factor of 1/e)</td></tr><tr><td style="text-align: right">to.inact_slow.steady</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">value that n would reach if v_gate was held constant</td></tr><tr><td style="text-align: right">to.inact_slow.n</td><td style="text-align: right"></td><td style="text-align: right">0.003978453093609672</td><td style="text-align: right">ratio of molecules in open conformation</td></tr><tr><td style="text-align: right">to.act.tau</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right"></td><td style="text-align: right">time constant for obtaining steady state (i.e. time until difference between n and steady has reduced by a factor of 1/e)</td></tr><tr><td style="text-align: right">to.act.steady</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">value that n would reach if v_gate was held constant</td></tr><tr><td style="text-align: right">to.act.n</td><td style="text-align: right"></td><td style="text-align: right">0.3884912691202426</td><td style="text-align: right">ratio of molecules in open conformation</td></tr><tr><td style="text-align: right">to.g</td><td style="text-align: right">&quot;S&quot;</td><td style="text-align: right"></td><td style="text-align: right">ion conductance</td></tr><tr><td style="text-align: right">to.i_open</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">i if open_ratio = 1</td></tr><tr><td style="text-align: right">to.open_ratio</td><td style="text-align: right">&quot;1&quot;</td><td style="text-align: right"></td><td style="text-align: right">ratio between 0 (fully closed) and 1 (fully open)</td></tr><tr><td style="text-align: right">to.i_ion</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">current used for ion flux</td></tr><tr><td style="text-align: right">vc.after_pulse</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">true after pulse has passed</td></tr><tr><td style="text-align: right">vc.within_pulse</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">true during pulse</td></tr><tr><td style="text-align: right">vc.vp_last</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">voltage of last pulse</td></tr><tr><td style="text-align: right">vc.tp_last</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">time stamp of start of last pulse</td></tr><tr><td style="text-align: right">vc.peak_indicator</td><td style="text-align: right"></td><td style="text-align: right">false</td><td style="text-align: right">forces event at peak (factor of 1e12 is required to detect zero crossing)</td></tr><tr><td style="text-align: right">vc.tail_i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">peak current after pulse</td></tr><tr><td style="text-align: right">vc.peak_i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">peak current during pulse</td></tr><tr><td style="text-align: right">vc.vs_tail</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_tail</td></tr><tr><td style="text-align: right">vc.vs_end</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_end</td></tr><tr><td style="text-align: right">vc.vs_peak</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of pulse associated with is_peak</td></tr><tr><td style="text-align: right">vc.is_end</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of current at end of last pulse</td></tr><tr><td style="text-align: right">vc.is_tail</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of peak tail current after last pulse</td></tr><tr><td style="text-align: right">vc.is_peak</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">steady step function of peak current during last pulse</td></tr><tr><td style="text-align: right">vc.v_pulse</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right"></td><td style="text-align: right">voltage during pulse (must be defined externally)</td></tr><tr><td style="text-align: right">vc.pulse_signal</td><td style="text-align: right"></td><td style="text-align: right">0</td><td style="text-align: right">0 during holding period, 1 during pulse</td></tr><tr><td style="text-align: right">vc.pulse_end</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">signals end of pulse</td></tr><tr><td style="text-align: right">vc.pulse_start</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">signals start of pulse</td></tr><tr><td style="text-align: right">vc.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">measured membrane current</td></tr><tr><td style="text-align: right">vc.g.p.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing into the pin</td></tr><tr><td style="text-align: right">vc.n.i</td><td style="text-align: right">&quot;A&quot;</td><td style="text-align: right"></td><td style="text-align: right">Current flowing into the pin</td></tr><tr><td style="text-align: right">$whenCondition1</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.pulse_end</td></tr><tr><td style="text-align: right">$whenCondition2</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.pulse_start</td></tr><tr><td style="text-align: right">$whenCondition3</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.peak_indicator &lt;&gt; pre(vc.peak_indicator) and vc.after_pulse or vc.pulse_end</td></tr><tr><td style="text-align: right">$whenCondition4</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">vc.peak_indicator &lt;&gt; pre(vc.peak_indicator) and vc.within_pulse or vc.pulse_end</td></tr><tr><td style="text-align: right">vc.g.p.v</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.0</td><td style="text-align: right">Potential at the pin</td></tr><tr><td style="text-align: right">vc.d_hold</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">20.0</td><td style="text-align: right">holding period</td></tr><tr><td style="text-align: right">vc.d_pulse</td><td style="text-align: right">&quot;s&quot;</td><td style="text-align: right">0.5</td><td style="text-align: right">pulse period</td></tr><tr><td style="text-align: right">vc.v_hold</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.08</td><td style="text-align: right">voltage during holding period</td></tr><tr><td style="text-align: right">v_start</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.06</td><td style="text-align: right">start value for pulse amplitude</td></tr><tr><td style="text-align: right">v_inc</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">0.005</td><td style="text-align: right">increment for pulse amplitude</td></tr><tr><td style="text-align: right">k_in</td><td style="text-align: right">&quot;mol/m3&quot;</td><td style="text-align: right">140.0</td><td style="text-align: right">intracellular potassium concentration</td></tr><tr><td style="text-align: right">k_ex</td><td style="text-align: right">&quot;mol/m3&quot;</td><td style="text-align: right">5.4</td><td style="text-align: right">extracellular potassium concentration</td></tr><tr><td style="text-align: right">temp</td><td style="text-align: right">&quot;K&quot;</td><td style="text-align: right">288.15</td><td style="text-align: right">cell medium temperature</td></tr><tr><td style="text-align: right">v_k</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">InaMo.Functions.Biochemical.nernst(k_in, k_ex, 1, temp)</td><td style="text-align: right">equilibrium potential for K+ ions</td></tr><tr><td style="text-align: right">to.v_eq</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">v_k</td><td style="text-align: right">equilibrium potential</td></tr><tr><td style="text-align: right">to.g_max</td><td style="text-align: right">&quot;S&quot;</td><td style="text-align: right">1.4e-08</td><td style="text-align: right">maximum conductance</td></tr><tr><td style="text-align: right">to.current_name</td><td style="text-align: right"></td><td style="text-align: right">&quot;I_to&quot;</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">l2.c</td><td style="text-align: right">&quot;F&quot;</td><td style="text-align: right">4e-11</td><td style="text-align: right">membrane capacitance</td></tr><tr><td style="text-align: right">l2.v_init</td><td style="text-align: right">&quot;V&quot;</td><td style="text-align: right">-0.09</td><td style="text-align: right">initial potential (from short initial stimulation)</td></tr><tr><td style="text-align: right">l2.use_init</td><td style="text-align: right"></td><td style="text-align: right">false</td><td style="text-align: right">determines whether initial value for v is used</td></tr></table>
      <p>To reproduce Figure S2A-S2D from Inada 2009, plot act_steady,
      inact_steady, inact_tau_fast and inact_tau_slow against v.</p>
      <p>Simulation protocol and parameters are chosen with the following
      rationale:</p>
      <ul>
        <li>StopTime: allow a plot from -120 to 80 mV</li>
        <li>Tolerance: left at default value, since derivatives are not
        relevant</li>
        <li>Interval: enough to give a smooth plot</li>
      </ul>
      <p>NOTE: Figure S2D shows a higher minimum for inact_slow.ftau.y_min
      (0.2 s instead of 0.1 s), but the formulas both in Inada 2009 and in
      the C++ code use the value of 0.1 s, which is why we keep it.</p>
    <pre><code class="language-modelica">model TransientOutwardSteady &quot;steady state of I_to, recreates Figures S2A-S2D from Inada 2009&quot;
  extends Modelica.Icons.Example;
  InaMo.Membrane.LipidBilayer l2(use_init = false) &quot;cell membrane&quot; annotation(
    Placement(transformation(extent = {{-17, -17}, {17, 17}})));
  InaMo.ExperimentalMethods.VoltageClamp.VoltageClamp vc &quot;voltage clamp&quot; annotation(
    Placement(transformation(extent = {{17, -17}, {51, 17}})));
  InaMo.Currents.Atrioventricular.TransientOutwardChannel to(v_eq = v_k) &quot;I_to&quot; annotation(
    Placement(transformation(extent = {{-51, -17}, {-17, 17}})));
  parameter SI.Concentration k_in = 140 &quot;intracellular potassium concentration&quot;;
  parameter SI.Concentration k_ex = 5.4 &quot;extracellular potassium concentration&quot;;
  parameter SI.Temperature temp = 310 &quot;cell medium temperature&quot;;
  parameter SI.Voltage v_k = nernst(k_in, k_ex, 1, temp) &quot;equilibrium potential for K+ ions&quot;;
  Real act_steady = to.act.steady &quot;steady state of activation gate&quot;;
  SI.Duration act_tau = to.act.tau &quot;time constant of activation gate&quot;;
  Real inact_steady = to.inact_slow.steady &quot;steady state of inactivation gates&quot;;
  SI.Duration inact_tau_fast = to.inact_fast.tau &quot;time constant of fast inactivation gate&quot;;
  SI.Duration inact_tau_slow = to.inact_slow.tau &quot;time constant of slow inactivation gate&quot;;
  SI.Voltage v(start = -0.12, fixed = true);
equation
  vc.v_stim = v;
  der(v) = 0.001;
  connect(to.p, l2.p) annotation(
    Line(points = {{-34, 18}, {-34, 18}, {-34, 28}, {0, 28}, {0, 18}, {0, 18}}, color = {0, 0, 255}));
  connect(l2.p, vc.p) annotation(
    Line(points = {{0, 18}, {0, 18}, {0, 28}, {34, 28}, {34, 18}, {34, 18}}, color = {0, 0, 255}));
  connect(to.n, l2.n) annotation(
    Line(points = {{-34, -16}, {-34, -16}, {-34, -28}, {0, -28}, {0, -16}, {0, -16}}, color = {0, 0, 255}));
  connect(l2.n, vc.n) annotation(
    Line(points = {{0, -16}, {0, -16}, {0, -28}, {34, -28}, {34, -16}, {34, -16}}, color = {0, 0, 255}));
  annotation(
    experiment(StartTime = 0, StopTime = 200, Tolerance = 1e-6, Interval = 1),
    __OpenModelica_simulationFlags(lv = &quot;LOG_STATS&quot;, s = &quot;dassl&quot;),
    __MoST_experiment(variableFilter = &quot;act_tau|act_steady|inact_steady|inact_tau_fast|inact_tau_slow|v|vc\\.v&quot;),
    Documentation(info = &quot;
    &lt;html&gt;
      &lt;p&gt;To reproduce Figure S2A-S2D from Inada 2009, plot act_steady,
      inact_steady, inact_tau_fast and inact_tau_slow against v.&lt;/p&gt;
      &lt;p&gt;Simulation protocol and parameters are chosen with the following
      rationale:&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;StopTime: allow a plot from -120 to 80 mV&lt;/li&gt;
        &lt;li&gt;Tolerance: left at default value, since derivatives are not
        relevant&lt;/li&gt;
        &lt;li&gt;Interval: enough to give a smooth plot&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;NOTE: Figure S2D shows a higher minimum for inact_slow.ftau.y_min
      (0.2 s instead of 0.1 s), but the formulas both in Inada 2009 and in
      the C++ code use the value of 0.1 s, which is why we keep it.&lt;/p&gt;
    &lt;/html&gt;
  &quot;));
end TransientOutwardSteady;</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 12 February 2021 13:28">Friday 12 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
